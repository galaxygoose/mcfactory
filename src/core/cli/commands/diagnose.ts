// This file is generated by the Architect Agent.
// Other agents must implement logic INSIDE this file only.
// Do NOT create or delete files. Respect the MIC + MIM.

import * as fs from 'fs';
import * as os from 'os';
import { MCFConfig } from '../../../types';
import { ConfigLoader } from '../../config/configLoader';

const CONFIG_PATH = 'mcf.config.json';

interface DiagnosticResult {
  name: string;
  status: 'PASS' | 'FAIL' | 'WARN';
  message: string;
}

export function diagnoseCommand(): void {
  console.log('üîç MCF System Diagnostics\n');

  const results: DiagnosticResult[] = [];

  // Check Node.js version
  const nodeVersion = process.version;
  const majorVersion = parseInt(nodeVersion.replace('v', '').split('.')[0]);
  results.push({
    name: 'Node.js Version',
    status: majorVersion >= 18 ? 'PASS' : 'FAIL',
    message: `Node.js ${nodeVersion} ${majorVersion >= 18 ? '(‚úì)' : '(‚úó requires >=18)'}`
  });

  // Check OS
  results.push({
    name: 'Operating System',
    status: 'PASS',
    message: `${os.type()} ${os.release()} (${os.arch()})`
  });

  // Check config file
  const configExists = fs.existsSync(CONFIG_PATH);
  results.push({
    name: 'Configuration File',
    status: configExists ? 'PASS' : 'FAIL',
    message: configExists ? `Found ${CONFIG_PATH}` : `Missing ${CONFIG_PATH} (run "mcf init")`
  });

  // Check config loading
  if (configExists) {
    try {
      const config = ConfigLoader.load() as MCFConfig;
      results.push({
        name: 'Config Loading',
        status: 'PASS',
        message: 'Configuration loaded successfully'
      });

      // Check providers
      const providerCount = Object.keys(config.providers || {}).length;
      results.push({
        name: 'Provider Configuration',
        status: providerCount > 0 ? 'PASS' : 'WARN',
        message: `${providerCount} provider(s) configured`
      });

      // Check API keys
      const providersWithKeys = Object.entries(config.providers || {})
        .filter(([_, config]) => config.apiKey || config.modelPath)
        .length;
      results.push({
        name: 'API Keys',
        status: providersWithKeys > 0 ? 'PASS' : 'WARN',
        message: `${providersWithKeys} provider(s) have API keys configured`
      });

    } catch (error) {
      results.push({
        name: 'Config Loading',
        status: 'FAIL',
        message: `Failed to load config: ${error}`
      });
    }
  }

  // Display results
  results.forEach(result => {
    const icon = result.status === 'PASS' ? '‚úì' : result.status === 'FAIL' ? '‚úó' : '‚ö†';
    console.log(`${icon} ${result.name}: ${result.message}`);
  });

  // Summary
  const failCount = results.filter(r => r.status === 'FAIL').length;
  const warnCount = results.filter(r => r.status === 'WARN').length;

  console.log('\nüìä Summary:');
  if (failCount > 0) {
    console.log(`‚ùå ${failCount} failure(s), ${warnCount} warning(s)`);
    console.log('Please fix the failing checks before proceeding.');
  } else if (warnCount > 0) {
    console.log(`‚ö†Ô∏è  ${warnCount} warning(s) - system is functional but may need configuration`);
  } else {
    console.log('‚úÖ All checks passed - system is ready!');
  }
}
