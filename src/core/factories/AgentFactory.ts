// This file is generated by the Architect Agent.
// Other agents must implement logic INSIDE this file only.
// Do NOT create or delete files. Respect the MIC + MIM.

import {
  Factory,
  SummarizationInput,
  SummarizationOutput,
  SentimentInput,
  SentimentOutput,
  CategorizationInput,
  CategorizationOutput,
  FactoryOptions,
  ProviderRequest,
  ProviderResponse
} from '../../types';
import { ProviderRegistry } from '../providers/providerRegistry';

export class AgentFactory {
  // Separate methods for each agent type to avoid type ambiguity
  async summarizeText(input: SummarizationInput, options?: FactoryOptions): Promise<SummarizationOutput> {
    return this.doSummarize(input, options);
  }

  async analyzeSentiment(input: SentimentInput, options?: FactoryOptions): Promise<SentimentOutput> {
    return this.doAnalyzeSentiment(input, options);
  }

  async categorizeText(input: CategorizationInput, options?: FactoryOptions): Promise<CategorizationOutput> {
    return this.doCategorize(input, options);
  }

  // Simplified run method that returns any to avoid type conflicts
  // Services should ideally use the specific methods: summarizeText, analyzeSentiment, categorizeText
  async run(input: any, options?: FactoryOptions): Promise<any> {
    if ('length' in input) {
      return this.doSummarize(input, options);
    }

    // Use type field to determine which service is calling
    if (input.type === 'sentiment') {
      return this.doAnalyzeSentiment(input, options);
    } else if (input.type === 'categorization') {
      return this.doCategorize(input, options);
    } else {
      // Default fallback
      return this.doCategorize(input, options);
    }
  }

  private async doSummarize(input: SummarizationInput, options?: FactoryOptions): Promise<SummarizationOutput> {
    const providerName = options?.provider || 'openai';
    const provider = ProviderRegistry.get(providerName);

    if (!provider) {
      throw new Error(`Provider ${providerName} not found`);
    }

    const prompt = this.buildSummarizationPrompt(input);

    const request: ProviderRequest = {
      model: 'gpt-4',
      input: prompt,
      options: {
        temperature: 0.3,
        max_tokens: input.length === 'long' ? 500 : input.length === 'medium' ? 300 : 150,
        ...options?.metadata
      }
    };

    const response: ProviderResponse = await provider.callModel(request);

    return this.parseSummarizationResponse(response, input);
  }

  private async doAnalyzeSentiment(input: SentimentInput, options?: FactoryOptions): Promise<SentimentOutput> {
    const providerName = options?.provider || 'openai';
    const provider = ProviderRegistry.get(providerName);

    if (!provider) {
      throw new Error(`Provider ${providerName} not found`);
    }

    const prompt = this.buildSentimentPrompt(input);

    const request: ProviderRequest = {
      model: 'gpt-4',
      input: prompt,
      options: {
        temperature: 0.2,
        max_tokens: 100,
        ...options?.metadata
      }
    };

    const response: ProviderResponse = await provider.callModel(request);

    return this.parseSentimentResponse(response);
  }

  private async doCategorize(input: CategorizationInput, options?: FactoryOptions): Promise<CategorizationOutput> {
    const providerName = options?.provider || 'openai';
    const provider = ProviderRegistry.get(providerName);

    if (!provider) {
      throw new Error(`Provider ${providerName} not found`);
    }

    const prompt = this.buildCategorizationPrompt(input);

    const request: ProviderRequest = {
      model: 'gpt-4',
      input: prompt,
      options: {
        temperature: 0.2,
        max_tokens: 200,
        ...options?.metadata
      }
    };

    const response: ProviderResponse = await provider.callModel(request);

    return this.parseCategorizationResponse(response);
  }

  private buildSummarizationPrompt(input: SummarizationInput): string {
    const length = input.length || 'medium';
    const lengthDesc = {
      short: 'brief (2-3 sentences)',
      medium: 'concise (4-6 sentences)',
      long: 'comprehensive (8-12 sentences)'
    };

    return `Summarize the following text in a ${lengthDesc[length]} summary that captures the main points and key details.

Text to summarize:
"${input.text}"

Provide only the summary, no additional commentary.`;
  }

  private buildSentimentPrompt(input: SentimentInput): string {
    return `Analyze the sentiment of the following text. Classify it as positive, neutral, or negative, and provide a confidence score between 0 and 1.

Text to analyze:
"${input.text}"

Respond in JSON format with the following structure:
{
  "label": "positive" | "neutral" | "negative",
  "score": number
}`;
  }

  private buildCategorizationPrompt(input: CategorizationInput): string {
    return `Analyze the following text and provide relevant tags and an optional main category. Tags should be specific keywords or phrases that describe the content.

Text to categorize:
"${input.text}"

Respond in JSON format with the following structure:
{
  "tags": ["tag1", "tag2", "tag3"],
  "category": "optional_main_category"
}`;
  }

  private parseSummarizationResponse(response: ProviderResponse, input: SummarizationInput): SummarizationOutput {
    const summary = typeof response.output === 'string'
      ? response.output.trim()
      : JSON.stringify(response.output);

    return {
      summary,
      length: input.length || 'medium'
    };
  }

  private parseSentimentResponse(response: ProviderResponse): SentimentOutput {
    try {
      const result = typeof response.output === 'string'
        ? JSON.parse(response.output)
        : response.output;

      const label = result.label || 'neutral';
      const score = typeof result.score === 'number' ? result.score : 0.5;

      return {
        label: label as "positive" | "neutral" | "negative",
        score
      };
    } catch (error) {
      // Fallback parsing
      const output = typeof response.output === 'string' ? response.output.toLowerCase() : '';

      let label: "positive" | "neutral" | "negative" = 'neutral';
      let score = 0.5;

      if (output.includes('positive')) {
        label = 'positive';
        score = 0.8;
      } else if (output.includes('negative')) {
        label = 'negative';
        score = 0.8;
      }

      return { label, score };
    }
  }

  private parseCategorizationResponse(response: ProviderResponse): CategorizationOutput {
    try {
      const result = typeof response.output === 'string'
        ? JSON.parse(response.output)
        : response.output;

      return {
        tags: Array.isArray(result.tags) ? result.tags : [],
        category: typeof result.category === 'string' ? result.category : undefined
      };
    } catch (error) {
      // Fallback parsing - extract potential tags from text
      const output = typeof response.output === 'string' ? response.output : '';
      const tags = output.split(/[,;]/).map(tag => tag.trim()).filter(tag => tag.length > 0);

      return {
        tags: tags.length > 0 ? tags : ['uncategorized'],
        category: undefined
      };
    }
  }
}
