// This file is generated by the Architect Agent.
// Other agents must implement logic INSIDE this file only.
// Do NOT create or delete files. Respect the MIC + MIM.

import { Factory, FactoryOptions } from '../../types';
// Note: Data utilities are scaffolded - implementing basic versions inline

export interface DataProcessingInput {
  text: string;
  operations: DataOperation[];
}

export interface DataProcessingOutput {
  processedText: string;
  metadata?: Record<string, any>;
}

export type DataOperation =
  | 'clean'
  | 'clean_html'
  | 'deduplicate'
  | 'normalize_emojis'
  | 'extract_entities'
  | 'filter_profanity'
  | 'split_sentences'
  | 'chunk_text'
  | 'normalize_unicode';

export class DataFactory implements Factory<DataProcessingInput, DataProcessingOutput> {
  async run(input: DataProcessingInput, options?: FactoryOptions): Promise<DataProcessingOutput> {
    let processedText = input.text;
    const metadata: Record<string, any> = {};


    // Apply each operation in sequence
    for (const operation of input.operations) {
      try {
        const result = await this.applyOperation(processedText, operation, options);
        processedText = result.text;
        if (result.metadata) {
          metadata[operation] = result.metadata;
        }

      } catch (error) {
        console.error(`Error applying operation ${operation}:`, error);
        // Continue with other operations unless it's a critical error
        if (options?.metadata?.failFast) {
          throw error;
        }
      }
    }


    return {
      processedText,
      metadata: Object.keys(metadata).length > 0 ? metadata : undefined
    };
  }

  private async applyOperation(
    text: string,
    operation: DataOperation,
    options?: FactoryOptions
  ): Promise<{ text: string; inputLength: number; metadata?: any }> {
    const inputLength = text.length;

    switch (operation) {
      case 'clean':
        return {
          text: this.cleanText(text),
          inputLength
        };

      case 'clean_html':
        return {
          text: this.cleanHTML(text),
          inputLength
        };

      case 'deduplicate':
        return {
          text: this.deduper(text),
          inputLength
        };

      case 'normalize_emojis':
        return {
          text: this.emojiNormalizer(text),
          inputLength
        };

      case 'extract_entities':
        const entities = this.entityExtractor(text);
        return {
          text, // Entity extraction doesn't modify text
          inputLength,
          metadata: { entities }
        };

      case 'filter_profanity':
        return {
          text: this.profanityFilter(text),
          inputLength
        };

      case 'split_sentences':
        const sentences = this.sentenceSplitter(text);
        return {
          text, // Sentence splitting doesn't modify text
          inputLength,
          metadata: { sentences, sentenceCount: sentences.length }
        };

      case 'chunk_text':
        const chunks = this.textChunker(text, options?.metadata?.chunkSize || 1000);
        return {
          text, // Text chunking doesn't modify text
          inputLength,
          metadata: { chunks, chunkCount: chunks.length }
        };

      case 'normalize_unicode':
        return {
          text: this.unicodeNormalizer(text),
          inputLength
        };

      default:
        throw new Error(`Unknown data processing operation: ${operation}`);
    }
  }

  // Inline implementations of data processing utilities
  private cleanText(text: string): string {
    return text
      .replace(/\s+/g, ' ') // Replace multiple spaces with single space
      .replace(/[\r\n]+/g, ' ') // Replace line breaks with spaces
      .trim();
  }

  private cleanHTML(text: string): string {
    return text
      .replace(/<[^>]*>/g, '') // Remove HTML tags
      .replace(/&[^;]+;/g, ' ') // Replace HTML entities with spaces
      .trim();
  }

  private deduper(text: string): string {
    // Simple deduplication - remove consecutive duplicate words
    const words = text.split(/\s+/);
    const deduped: string[] = [];
    for (const word of words) {
      if (deduped.length === 0 || deduped[deduped.length - 1] !== word) {
        deduped.push(word);
      }
    }
    return deduped.join(' ');
  }

  private emojiNormalizer(text: string): string {
    // Simple emoji normalization - convert common emoji variations
    return text
      .replace(/ðŸ˜Š|ðŸ™‚|â˜ºï¸/g, 'smile')
      .replace(/â¤ï¸|ðŸ’–|ðŸ’•/g, 'heart')
      .replace(/ðŸ”¥|ðŸ’¯/g, 'fire');
  }

  private entityExtractor(text: string): any[] {
    // Simple entity extraction - find potential names, dates, etc.
    const entities: any[] = [];

    // Extract potential email addresses
    const emails = text.match(/\b[A-Za-z0-9._%+-]+@[A-Za-z0-9.-]+\.[A-Z|a-z]{2,}\b/g);
    if (emails) {
      entities.push(...emails.map(email => ({ type: 'email', value: email })));
    }

    // Extract potential phone numbers
    const phones = text.match(/\b\d{3}[-.]?\d{3}[-.]?\d{4}\b/g);
    if (phones) {
      entities.push(...phones.map(phone => ({ type: 'phone', value: phone })));
    }

    return entities;
  }

  private profanityFilter(text: string): string {
    // Simple profanity filter - replace common profane words
    const profanities = ['damn', 'hell', 'crap', 'stupid', 'idiot'];
    let filtered = text;
    profanities.forEach(word => {
      const regex = new RegExp(`\\b${word}\\b`, 'gi');
      filtered = filtered.replace(regex, '***');
    });
    return filtered;
  }

  private sentenceSplitter(text: string): string[] {
    return text
      .split(/[.!?]+/)
      .map(s => s.trim())
      .filter(s => s.length > 0);
  }

  private textChunker(text: string, chunkSize: number): string[] {
    const chunks: string[] = [];
    const sentences = this.sentenceSplitter(text);

    let currentChunk = '';
    for (const sentence of sentences) {
      if (currentChunk.length + sentence.length > chunkSize && currentChunk.length > 0) {
        chunks.push(currentChunk.trim());
        currentChunk = sentence;
      } else {
        currentChunk += (currentChunk ? ' ' : '') + sentence;
      }
    }

    if (currentChunk) {
      chunks.push(currentChunk.trim());
    }

    return chunks;
  }

  private unicodeNormalizer(text: string): string {
    return text
      .normalize('NFD') // Decompose accented characters
      .replace(/[\u0300-\u036f]/g, '') // Remove diacritics
      .normalize('NFC'); // Recompose
  }
}
