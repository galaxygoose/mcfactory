// This file is generated by the Architect Agent.
// Other agents must implement logic INSIDE this file only.
// Do NOT create or delete files. Respect the MIC + MIM.

import {
  Factory,
  AIDetectionInput,
  AIDetectionOutput,
  FakeVoiceDetectionInput,
  FakeVoiceDetectionOutput,
  FactoryOptions,
  ProviderRequest,
  ProviderResponse
} from '../../types';
import { ProviderRegistry } from '../providers/providerRegistry';

export class DetectionFactory {
  async run(input: AIDetectionInput, options?: FactoryOptions): Promise<AIDetectionOutput>;
  async run(input: FakeVoiceDetectionInput, options?: FactoryOptions): Promise<FakeVoiceDetectionOutput>;
  async run(input: AIDetectionInput | FakeVoiceDetectionInput, options?: FactoryOptions): Promise<AIDetectionOutput | FakeVoiceDetectionOutput> {
    // Determine detection type based on input structure
    if (this.isAIDetectionInput(input)) {
      return this.detectAI(input, options);
    } else if (this.isFakeVoiceDetectionInput(input)) {
      return this.detectFakeVoice(input, options);
    } else {
      throw new Error('Invalid detection input type');
    }
  }

  private isAIDetectionInput(input: AIDetectionInput | FakeVoiceDetectionInput): input is AIDetectionInput {
    return 'text' in input && typeof input.text === 'string';
  }

  private isFakeVoiceDetectionInput(input: AIDetectionInput | FakeVoiceDetectionInput): input is FakeVoiceDetectionInput {
    return 'audioBuffer' in input && input.audioBuffer instanceof ArrayBuffer;
  }

  private async detectAI(input: AIDetectionInput, options?: FactoryOptions): Promise<AIDetectionOutput> {
    const providerName = options?.provider || 'openai';
    const provider = ProviderRegistry.get(providerName);

    if (!provider) {
      throw new Error(`Provider ${providerName} not found`);
    }

    const prompt = this.buildAIDetectionPrompt(input);

    const request: ProviderRequest = {
      model: 'gpt-4',
      input: prompt,
      options: {
        temperature: 0.1,
        max_tokens: 500,
        ...options?.metadata
      }
    };

    const response: ProviderResponse = await provider.callModel(request);

    return this.parseAIDetectionResponse(response);
  }

  private async detectFakeVoice(input: FakeVoiceDetectionInput, options?: FactoryOptions): Promise<FakeVoiceDetectionOutput> {
    // For fake voice detection, we'd typically use a specialized audio analysis provider
    // For now, we'll use a text-based approach or mock implementation
    // In a real implementation, this would analyze audio features

    const providerName = options?.provider || 'openai';
    const provider = ProviderRegistry.get(providerName);

    if (!provider) {
      throw new Error(`Provider ${providerName} not found`);
    }

    // Convert audio buffer to a format that can be analyzed
    // This is a simplified implementation
    const audioFeatures = this.extractAudioFeatures(input.audioBuffer);

    const prompt = this.buildFakeVoiceDetectionPrompt(audioFeatures);

    const request: ProviderRequest = {
      model: 'gpt-4',
      input: prompt,
      options: {
        temperature: 0.1,
        max_tokens: 300,
        ...options?.metadata
      }
    };

    const response: ProviderResponse = await provider.callModel(request);

    return this.parseFakeVoiceDetectionResponse(response);
  }

  private buildAIDetectionPrompt(input: AIDetectionInput): string {
    return `Analyze the following text and determine if it was likely generated by an AI language model. Provide a confidence score between 0 and 1, where 1 means definitely AI-generated and 0 means definitely human-written. Also provide any relevant features that influenced your decision.

Text to analyze:
"${input.text}"

Respond in JSON format with the following structure:
{
  "isAI": boolean,
  "confidence": number,
  "features": {
    "entropy": number,
    "perplexity": number,
    "stylometry": {"feature1": value1, "feature2": value2}
  }
}`;
  }

  private buildFakeVoiceDetectionPrompt(audioFeatures: any): string {
    return `Analyze the following audio features and determine if the voice is likely fake/synthesized. Provide a confidence score and relevant details.

Audio features: ${JSON.stringify(audioFeatures)}

Respond in JSON format with the following structure:
{
  "isFake": boolean,
  "confidence": number,
  "details": {"feature1": "analysis1", "feature2": "analysis2"}
}`;
  }

  private extractAudioFeatures(audioBuffer: ArrayBuffer): any {
    // Simplified audio feature extraction
    // In a real implementation, this would analyze spectrograms, MFCCs, etc.
    return {
      duration: audioBuffer.byteLength / 44100, // Rough estimate
      sampleRate: 44100,
      bitDepth: 16,
      channels: 1
    };
  }

  private parseAIDetectionResponse(response: ProviderResponse): AIDetectionOutput {
    try {
      const result = typeof response.output === 'string'
        ? JSON.parse(response.output)
        : response.output;

      return {
        isAI: result.isAI || false,
        confidence: result.confidence || 0,
        features: result.features || {}
      };
    } catch (error) {
      // Fallback parsing for non-JSON responses
      const output = typeof response.output === 'string' ? response.output : '';
      const isAI = output.toLowerCase().includes('ai') || output.toLowerCase().includes('generated');
      const confidence = isAI ? 0.8 : 0.2;

      return {
        isAI,
        confidence,
        features: {}
      };
    }
  }

  private parseFakeVoiceDetectionResponse(response: ProviderResponse): FakeVoiceDetectionOutput {
    try {
      const result = typeof response.output === 'string'
        ? JSON.parse(response.output)
        : response.output;

      return {
        isFake: result.isFake || false,
        confidence: result.confidence || 0,
        details: result.details || {}
      };
    } catch (error) {
      // Fallback parsing
      const output = typeof response.output === 'string' ? response.output : '';
      const isFake = output.toLowerCase().includes('fake') || output.toLowerCase().includes('synthetic');
      const confidence = isFake ? 0.7 : 0.3;

      return {
        isFake,
        confidence,
        details: {}
      };
    }
  }
}
