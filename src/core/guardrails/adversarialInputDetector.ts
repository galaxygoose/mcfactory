// This file is generated by the Architect Agent.
// Other agents must implement logic INSIDE this file only.
// Do NOT create or delete files. Respect the MIC + MIM.

import { GuardrailResult } from '../../types';

export function detectAdversarialInput(text: string): GuardrailResult {
  const reasons: string[] = [];

  if (!text || typeof text !== 'string') {
    reasons.push('Invalid input: text must be a non-empty string');
    return { safe: false, reasons };
  }

  const lowerText = text.toLowerCase();

  // Check for common adversarial patterns
  const adversarialPatterns = [
    // Attempted prompt injection
    /ignore previous instructions/i,
    /system prompt/i,
    /you are now/i,
    /override/i,
    /bypass/i,

    // Role-playing attacks
    /act as.*administrator/i,
    /role.*play/i,
    /pretend.*to.*be/i,

    // Encoding tricks
    /base64/i,
    /hex/i,
    /encoded/i,

    // Common jailbreak attempts
    /dan.*jailbreak/i,
    /uncensored/i,
    /developer.*mode/i,

    // Repetitive patterns that might be adversarial
    /(.{10,})\1{2,}/, // Repeated sequences

    // Excessive special characters
    /[^\w\s]{10,}/, // 10+ consecutive special chars

    // Very long words (potentially encoded)
    /\b\w{50,}\b/, // Words longer than 50 chars
  ];

  // Check text length - extremely long inputs might be adversarial
  if (text.length > 10000) {
    reasons.push('Input text is excessively long (>10000 characters)');
  }

  // Check for pattern matches
  for (const pattern of adversarialPatterns) {
    if (pattern.test(lowerText)) {
      reasons.push('Detected adversarial pattern in input');
      break; // Only add once
    }
  }

  // Check for high entropy (suspicious randomness)
  const entropy = calculateShannonEntropy(text);
  if (entropy > 4.5) { // High entropy threshold
    reasons.push('High entropy detected - potential obfuscated content');
  }

  // Check for unusual character distribution
  const charCounts: Record<string, number> = {};
  for (const char of text) {
    charCounts[char] = (charCounts[char] || 0) + 1;
  }

  const uniqueChars = Object.keys(charCounts).length;
  const totalChars = text.length;

  // Very high unique character ratio might indicate obfuscation
  if (uniqueChars / totalChars > 0.8 && totalChars > 100) {
    reasons.push('Unusual character distribution - potential obfuscation');
  }

  return {
    safe: reasons.length === 0,
    reasons: reasons.length > 0 ? reasons : undefined
  };
}

function calculateShannonEntropy(text: string): number {
  const charCounts: Record<string, number> = {};
  for (const char of text) {
    charCounts[char] = (charCounts[char] || 0) + 1;
  }

  const length = text.length;
  let entropy = 0;

  for (const count of Object.values(charCounts)) {
    const probability = count / length;
    entropy -= probability * Math.log2(probability);
  }

  return entropy;
}
