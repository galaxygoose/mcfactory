// This file is generated by the Architect Agent.
// Other agents must implement logic INSIDE this file only.
// Do NOT create or delete files. Respect the MIC + MIM.

export function scoreHallucinationRisk(text: string): number {
  if (!text || typeof text !== 'string' || text.length === 0) {
    return 0;
  }

  let riskScore = 0;

  // Length-based risk assessment
  const wordCount = text.split(/\s+/).length;

  // Very short texts might be more prone to hallucination
  if (wordCount < 5) {
    riskScore += 0.2;
  }

  // Extremely long texts might indicate rambling
  if (wordCount > 1000) {
    riskScore += 0.1;
  }

  // Check for repetitive patterns
  const sentences = text.split(/[.!?]+/).filter(s => s.trim().length > 0);
  if (sentences.length > 3) {
    const uniqueSentences = new Set(sentences.map(s => s.trim().toLowerCase()));
    const repetitionRatio = 1 - (uniqueSentences.size / sentences.length);

    if (repetitionRatio > 0.3) {
      riskScore += 0.3; // High repetition indicates potential hallucination
    }
  }

  // Check for unusual word patterns
  const words = text.toLowerCase().match(/\b\w+\b/g) || [];
  const uniqueWords = new Set(words);
  const vocabularyDiversity = uniqueWords.size / words.length;

  // Very low diversity might indicate repetitive or nonsensical content
  if (vocabularyDiversity < 0.3 && words.length > 20) {
    riskScore += 0.25;
  }

  // Check for hallucination indicators
  const hallucinationIndicators = [
    /\b(definitely|absolutely|certainly|obviously)\b.*\b(not|never|impossible)\b/i,
    /\b(always|never|everyone|nobody)\b.*\b(except|but|however)\b/i,
    /\b(impossible|cannot|never)\b.*\b(actually|in fact|however)\b/i,
    /\b(all|every|none|no one)\b.*\b(except|but|however)\b/i,
  ];

  for (const pattern of hallucinationIndicators) {
    if (pattern.test(text)) {
      riskScore += 0.1;
    }
  }

  // Check for overconfidence markers
  const confidenceMarkers = [
    'i\'m certain',
    'i know for sure',
    'definitely',
    'absolutely sure',
    'without a doubt',
    'guaranteed',
    'proven fact',
  ];

  const lowerText = text.toLowerCase();
  for (const marker of confidenceMarkers) {
    if (lowerText.includes(marker)) {
      riskScore += 0.05;
    }
  }

  // Check for contradictory statements within reasonable distance
  const contradictions = [
    ['yes', 'no'],
    ['true', 'false'],
    ['correct', 'wrong'],
    ['right', 'wrong'],
    ['good', 'bad'],
    ['safe', 'dangerous'],
  ];

  for (const [word1, word2] of contradictions) {
    const index1 = lowerText.indexOf(word1);
    const index2 = lowerText.indexOf(word2);

    if (index1 !== -1 && index2 !== -1 && Math.abs(index1 - index2) < 200) {
      riskScore += 0.15;
    }
  }

  // Cap the score between 0 and 1
  return Math.min(Math.max(riskScore, 0), 1);
}
