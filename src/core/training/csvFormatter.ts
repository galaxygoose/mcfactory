// This file is generated by the Architect Agent.
// Other agents must implement logic INSIDE this file only.
// Do NOT create or delete files. Respect the MIC + MIM.

import { TrainingExample } from '../../types';

/**
 * Formats training examples into CSV format
 * Handles nested metadata by flattening it into columns
 */
export function formatCSV(data: TrainingExample[]): string {
  if (!Array.isArray(data) || data.length === 0) {
    return '';
  }

  // Flatten the training examples into tabular format
  const flattenedData = data.map(example => flattenTrainingExample(example));

  // Determine all possible columns from the flattened data
  const allColumns = getAllColumns(flattenedData);

  // Create CSV header
  const header = allColumns.join(',');

  // Create CSV rows
  const rows = flattenedData.map(row => {
    return allColumns.map(column => {
      const value = row[column];
      return escapeCSVValue(value);
    }).join(',');
  });

  return [header, ...rows].join('\n');
}

/**
 * Flattens a training example into a flat object suitable for CSV
 * Handles nested metadata by flattening it with dot notation
 */
function flattenTrainingExample(example: TrainingExample): Record<string, any> {
  const flattened: Record<string, any> = {};

  // Add core fields
  flattened.input = example.input || '';
  flattened.output = example.output || '';
  flattened.task = example.task || '';

  // Flatten metadata
  if (example.metadata && typeof example.metadata === 'object') {
    flattenObject(example.metadata, flattened, 'metadata');
  }

  return flattened;
}

/**
 * Recursively flattens an object using dot notation for nested keys
 */
function flattenObject(obj: Record<string, any>, result: Record<string, any>, prefix: string = ''): void {
  for (const [key, value] of Object.entries(obj)) {
    const fullKey = prefix ? `${prefix}.${key}` : key;

    if (value === null || value === undefined) {
      result[fullKey] = '';
    } else if (typeof value === 'object' && !Array.isArray(value)) {
      // Recursively flatten nested objects
      flattenObject(value, result, fullKey);
    } else if (Array.isArray(value)) {
      // Convert arrays to JSON strings
      result[fullKey] = JSON.stringify(value);
    } else if (typeof value === 'string') {
      result[fullKey] = value;
    } else {
      // Convert other types to strings
      result[fullKey] = String(value);
    }
  }
}

/**
 * Determines all possible columns from the flattened data
 * Ensures consistent column ordering across all rows
 */
function getAllColumns(data: Record<string, any>[]): string[] {
  const columnSet = new Set<string>();

  // Collect all possible columns
  data.forEach(row => {
    Object.keys(row).forEach(key => columnSet.add(key));
  });

  // Sort columns for consistent ordering
  const columns = Array.from(columnSet).sort();

  // Ensure core columns come first
  const coreColumns = ['input', 'output', 'task'];
  const otherColumns = columns.filter(col => !coreColumns.includes(col));

  return [...coreColumns, ...otherColumns];
}

/**
 * Escapes a value for CSV format
 * Handles commas, quotes, and newlines properly
 */
function escapeCSVValue(value: any): string {
  if (value === null || value === undefined) {
    return '';
  }

  const stringValue = String(value);

  // If the value contains commas, quotes, or newlines, wrap it in quotes
  // and escape any existing quotes
  if (stringValue.includes(',') || stringValue.includes('"') || stringValue.includes('\n') || stringValue.includes('\r')) {
    return `"${stringValue.replace(/"/g, '""')}"`;
  }

  return stringValue;
}

/**
 * Parses CSV string back into TrainingExample array
 * Useful for loading previously formatted data
 */
export function parseCSV(csvString: string): TrainingExample[] {
  if (!csvString || typeof csvString !== 'string') {
    return [];
  }

  const lines = csvString.trim().split('\n');
  if (lines.length < 2) { // Need at least header + one data row
    return [];
  }

  const headerLine = lines[0];
  const headers = parseCSVLine(headerLine);

  const examples: TrainingExample[] = [];

  // Process data rows
  for (let i = 1; i < lines.length; i++) {
    const line = lines[i].trim();
    if (!line) continue;

    try {
      const values = parseCSVLine(line);

      if (values.length !== headers.length) {
        console.warn(`Skipping line ${i + 1}: column count mismatch`);
        continue;
      }

      // Create row object
      const row: Record<string, any> = {};
      headers.forEach((header, index) => {
        row[header] = values[index];
      });

      // Reconstruct training example
      const example = reconstructTrainingExample(row);
      examples.push(example);
    } catch (error) {
      console.warn(`Failed to parse CSV line ${i + 1}: ${error}`);
    }
  }

  return examples;
}

/**
 * Parses a single CSV line, handling quoted values and escaped quotes
 */
function parseCSVLine(line: string): string[] {
  const values: string[] = [];
  let current = '';
  let inQuotes = false;
  let i = 0;

  while (i < line.length) {
    const char = line[i];
    const nextChar = line[i + 1];

    if (char === '"') {
      if (inQuotes && nextChar === '"') {
        // Escaped quote
        current += '"';
        i += 2;
        continue;
      } else {
        // Toggle quote state
        inQuotes = !inQuotes;
      }
    } else if (char === ',' && !inQuotes) {
      // End of field
      values.push(current);
      current = '';
    } else {
      current += char;
    }

    i++;
  }

  // Add the last field
  values.push(current);

  return values;
}

/**
 * Reconstructs a TrainingExample from a flattened CSV row
 */
function reconstructTrainingExample(row: Record<string, any>): TrainingExample {
  const example: TrainingExample = {
    input: row.input || '',
    task: row.task || ''
  };

  // Add output if present
  if (row.output) {
    example.output = row.output;
  }

  // Reconstruct metadata from flattened fields
  const metadata: Record<string, any> = {};

  Object.entries(row).forEach(([key, value]) => {
    if (key.startsWith('metadata.')) {
      const metaKey = key.substring(9); // Remove 'metadata.' prefix
      setNestedValue(metadata, metaKey, value);
    }
  });

  if (Object.keys(metadata).length > 0) {
    example.metadata = metadata;
  }

  return example;
}

/**
 * Sets a nested value in an object using dot notation
 */
function setNestedValue(obj: Record<string, any>, path: string, value: any): void {
  const keys = path.split('.');
  let current = obj;

  for (let i = 0; i < keys.length - 1; i++) {
    const key = keys[i];
    if (!(key in current) || typeof current[key] !== 'object' || current[key] === null) {
      current[key] = {};
    }
    current = current[key];
  }

  const lastKey = keys[keys.length - 1];

  // Try to parse JSON strings back to arrays/objects
  if (typeof value === 'string') {
    try {
      const parsed = JSON.parse(value);
      current[lastKey] = parsed;
      return;
    } catch {
      // Not valid JSON, keep as string
    }
  }

  current[lastKey] = value;
}

/**
 * Validates that the CSV output is properly formatted
 */
export function validateCSV(csvString: string): { valid: boolean; errors: string[] } {
  const errors: string[] = [];
  const lines = csvString.trim().split('\n');

  if (lines.length < 1) {
    return { valid: false, errors: ['CSV string is empty'] };
  }

  if (lines.length < 2) {
    return { valid: false, errors: ['CSV must have at least a header row and one data row'] };
  }

  const headerLine = lines[0];
  const expectedColumnCount = parseCSVLine(headerLine).length;

  lines.forEach((line, index) => {
    if (!line.trim()) {
      errors.push(`Line ${index + 1}: Empty line`);
      return;
    }

    const columns = parseCSVLine(line);
    if (columns.length !== expectedColumnCount) {
      errors.push(`Line ${index + 1}: Expected ${expectedColumnCount} columns, got ${columns.length}`);
    }

    // Validate required fields in data rows (not header)
    if (index > 0) {
      const headers = parseCSVLine(headerLine);
      const inputIndex = headers.indexOf('input');
      const taskIndex = headers.indexOf('task');

      if (inputIndex >= 0 && (!columns[inputIndex] || columns[inputIndex].trim() === '')) {
        errors.push(`Line ${index + 1}: Missing required 'input' field`);
      }

      if (taskIndex >= 0 && (!columns[taskIndex] || columns[taskIndex].trim() === '')) {
        errors.push(`Line ${index + 1}: Missing required 'task' field`);
      }
    }
  });

  return {
    valid: errors.length === 0,
    errors
  };
}
