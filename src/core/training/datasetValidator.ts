// This file is generated by the Architect Agent.
// Other agents must implement logic INSIDE this file only.
// Do NOT create or delete files. Respect the MIC + MIM.

import { TrainingExample } from '../../types';

/**
 * Validation configuration
 */
export interface ValidationConfig {
  strict?: boolean; // If true, fail on any error; if false, collect all errors
  checkDuplicates?: boolean; // Check for duplicate examples
  maxExamples?: number; // Maximum number of examples allowed
  minInputLength?: number; // Minimum input text length
  maxInputLength?: number; // Maximum input text length
  requiredTasks?: string[]; // List of required task types
  validateEmbeddings?: boolean; // Whether to validate embeddings if present
  customValidators?: Array<(example: TrainingExample, index: number) => ValidationError | null>;
}

/**
 * Validation error details
 */
export interface ValidationError {
  type: 'error' | 'warning';
  code: string;
  message: string;
  exampleIndex?: number;
  field?: string;
  value?: any;
}

/**
 * Validation result
 */
export interface ValidationResult {
  valid: boolean;
  errors: ValidationError[];
  warnings: ValidationError[];
  stats: {
    totalExamples: number;
    validExamples: number;
    errorCount: number;
    warningCount: number;
    taskDistribution: Record<string, number>;
    averageInputLength: number;
    averageOutputLength: number;
  };
}

/**
 * Validates a training dataset for consistency and quality
 */
export function validateDataset(
  data: TrainingExample[],
  config: ValidationConfig = {}
): ValidationResult {
  const {
    strict = false,
    checkDuplicates = true,
    maxExamples = 100000,
    minInputLength = 1,
    maxInputLength = 10000,
    requiredTasks = [],
    validateEmbeddings = true,
    customValidators = []
  } = config;

  const errors: ValidationError[] = [];
  const warnings: ValidationError[] = [];
  const taskDistribution: Record<string, number> = {};
  let totalInputLength = 0;
  let totalOutputLength = 0;
  let validExamples = 0;

  // Basic validation
  if (!Array.isArray(data)) {
    errors.push({
      type: 'error',
      code: 'INVALID_DATA_TYPE',
      message: 'Dataset must be an array',
      field: 'data'
    });
    return createResult(errors, warnings, 0, validExamples, taskDistribution, 0, 0);
  }

  if (data.length === 0) {
    warnings.push({
      type: 'warning',
      code: 'EMPTY_DATASET',
      message: 'Dataset is empty'
    });
    return createResult(errors, warnings, 0, 0, taskDistribution, 0, 0);
  }

  if (data.length > maxExamples) {
    errors.push({
      type: 'error',
      code: 'TOO_MANY_EXAMPLES',
      message: `Dataset has ${data.length} examples, exceeds maximum of ${maxExamples}`
    });
  }

  // Check for duplicates if requested
  if (checkDuplicates) {
    const duplicateIndices = findDuplicates(data);
    duplicateIndices.forEach(([index1, index2]) => {
      warnings.push({
        type: 'warning',
        code: 'DUPLICATE_EXAMPLE',
        message: `Examples ${index1} and ${index2} appear to be duplicates`,
        exampleIndex: index1
      });
    });
  }

  // Validate each example
  data.forEach((example, index) => {
    const exampleErrors = validateExample(example, index, {
      minInputLength,
      maxInputLength,
      validateEmbeddings
    });

    errors.push(...exampleErrors.errors);
    warnings.push(...exampleErrors.warnings);

    if (exampleErrors.errors.length === 0) {
      validExamples++;
    }

    // Update statistics
    if (example.task) {
      taskDistribution[example.task] = (taskDistribution[example.task] || 0) + 1;
    }

    if (example.input) {
      totalInputLength += example.input.length;
    }

    if (example.output) {
      totalOutputLength += example.output.length;
    }

    // Run custom validators
    customValidators.forEach(validator => {
      const customError = validator(example, index);
      if (customError) {
        if (customError.type === 'error') {
          errors.push(customError);
        } else {
          warnings.push(customError);
        }
      }
    });
  });

  // Check required tasks
  requiredTasks.forEach(requiredTask => {
    if (!taskDistribution[requiredTask]) {
      errors.push({
        type: 'error',
        code: 'MISSING_REQUIRED_TASK',
        message: `Required task '${requiredTask}' not found in dataset`
      });
    }
  });

  const avgInputLength = data.length > 0 ? totalInputLength / data.length : 0;
  const avgOutputLength = data.length > 0 ? totalOutputLength / data.length : 0;

  return createResult(errors, warnings, data.length, validExamples, taskDistribution, avgInputLength, avgOutputLength);
}

/**
 * Validates a single training example
 */
function validateExample(
  example: any,
  index: number,
  config: { minInputLength: number; maxInputLength: number; validateEmbeddings: boolean }
): { errors: ValidationError[]; warnings: ValidationError[] } {
  const errors: ValidationError[] = [];
  const warnings: ValidationError[] = [];

  // Check if example is an object
  if (!example || typeof example !== 'object') {
    errors.push({
      type: 'error',
      code: 'INVALID_EXAMPLE_TYPE',
      message: 'Example must be an object',
      exampleIndex: index
    });
    return { errors, warnings };
  }

  // Validate input field
  if (!example.input) {
    errors.push({
      type: 'error',
      code: 'MISSING_INPUT',
      message: 'Example missing required field: input',
      exampleIndex: index,
      field: 'input'
    });
  } else if (typeof example.input !== 'string') {
    errors.push({
      type: 'error',
      code: 'INVALID_INPUT_TYPE',
      message: 'Input field must be a string',
      exampleIndex: index,
      field: 'input',
      value: example.input
    });
  } else {
    if (example.input.length < config.minInputLength) {
      errors.push({
        type: 'error',
        code: 'INPUT_TOO_SHORT',
        message: `Input length ${example.input.length} is below minimum ${config.minInputLength}`,
        exampleIndex: index,
        field: 'input'
      });
    }

    if (example.input.length > config.maxInputLength) {
      errors.push({
        type: 'error',
        code: 'INPUT_TOO_LONG',
        message: `Input length ${example.input.length} exceeds maximum ${config.maxInputLength}`,
        exampleIndex: index,
        field: 'input'
      });
    }

    // Check for empty or whitespace-only input
    if (example.input.trim().length === 0) {
      errors.push({
        type: 'error',
        code: 'EMPTY_INPUT',
        message: 'Input field is empty or contains only whitespace',
        exampleIndex: index,
        field: 'input'
      });
    }
  }

  // Validate task field
  if (!example.task) {
    errors.push({
      type: 'error',
      code: 'MISSING_TASK',
      message: 'Example missing required field: task',
      exampleIndex: index,
      field: 'task'
    });
  } else if (typeof example.task !== 'string') {
    errors.push({
      type: 'error',
      code: 'INVALID_TASK_TYPE',
      message: 'Task field must be a string',
      exampleIndex: index,
      field: 'task',
      value: example.task
    });
  } else if (example.task.trim().length === 0) {
    errors.push({
      type: 'error',
      code: 'EMPTY_TASK',
      message: 'Task field is empty',
      exampleIndex: index,
      field: 'task'
    });
  }

  // Validate output field (optional)
  if (example.output !== undefined && example.output !== null) {
    if (typeof example.output !== 'string') {
      errors.push({
        type: 'error',
        code: 'INVALID_OUTPUT_TYPE',
        message: 'Output field must be a string if present',
        exampleIndex: index,
        field: 'output',
        value: example.output
      });
    }
  }

  // Validate metadata
  if (example.metadata !== undefined) {
    if (typeof example.metadata !== 'object' || example.metadata === null) {
      errors.push({
        type: 'error',
        code: 'INVALID_METADATA_TYPE',
        message: 'Metadata field must be an object if present',
        exampleIndex: index,
        field: 'metadata'
      });
    } else if (config.validateEmbeddings) {
      // Validate embeddings if present
      validateEmbeddings(example.metadata, index, errors, warnings);
    }
  }

  return { errors, warnings };
}

/**
 * Validates embeddings in metadata
 */
function validateEmbeddings(
  metadata: Record<string, any>,
  exampleIndex: number,
  errors: ValidationError[],
  warnings: ValidationError[]
): void {
  Object.entries(metadata).forEach(([key, value]) => {
    if (key.includes('embedding') && Array.isArray(value)) {
      const embedding = value as number[];

      if (embedding.length === 0) {
        warnings.push({
          type: 'warning',
          code: 'EMPTY_EMBEDDING',
          message: `Embedding field '${key}' is empty`,
          exampleIndex,
          field: `metadata.${key}`
        });
        return;
      }

      // Check for NaN or infinite values
      if (embedding.some(val => !isFinite(val))) {
        errors.push({
          type: 'error',
          code: 'INVALID_EMBEDDING_VALUES',
          message: `Embedding field '${key}' contains NaN or infinite values`,
          exampleIndex,
          field: `metadata.${key}`
        });
      }

      // Check for reasonable dimensions (embeddings should have dozens to thousands of dimensions)
      if (embedding.length < 10) {
        warnings.push({
          type: 'warning',
          code: 'EMBEDDING_TOO_SMALL',
          message: `Embedding field '${key}' has only ${embedding.length} dimensions, which seems low`,
          exampleIndex,
          field: `metadata.${key}`
        });
      }

      if (embedding.length > 10000) {
        warnings.push({
          type: 'warning',
          code: 'EMBEDDING_TOO_LARGE',
          message: `Embedding field '${key}' has ${embedding.length} dimensions, which seems high`,
          exampleIndex,
          field: `metadata.${key}`
        });
      }
    }
  });
}

/**
 * Finds duplicate examples in the dataset
 */
function findDuplicates(data: TrainingExample[]): Array<[number, number]> {
  const duplicates: Array<[number, number]> = [];
  const seen = new Map<string, number>();

  data.forEach((example, index) => {
    // Create a simple hash of the example for comparison
    const hash = createExampleHash(example);

    if (seen.has(hash)) {
      duplicates.push([seen.get(hash)!, index]);
    } else {
      seen.set(hash, index);
    }
  });

  return duplicates;
}

/**
 * Creates a simple hash of an example for duplicate detection
 */
function createExampleHash(example: TrainingExample): string {
  const normalized = {
    input: example.input?.trim().toLowerCase() || '',
    output: example.output?.trim().toLowerCase() || '',
    task: example.task?.trim().toLowerCase() || ''
  };

  return JSON.stringify(normalized);
}

/**
 * Creates a validation result object
 */
function createResult(
  errors: ValidationError[],
  warnings: ValidationError[],
  totalExamples: number,
  validExamples: number,
  taskDistribution: Record<string, number>,
  avgInputLength: number,
  avgOutputLength: number
): ValidationResult {
  return {
    valid: errors.length === 0,
    errors,
    warnings,
    stats: {
      totalExamples,
      validExamples,
      errorCount: errors.length,
      warningCount: warnings.length,
      taskDistribution,
      averageInputLength: Math.round(avgInputLength * 100) / 100,
      averageOutputLength: Math.round(avgOutputLength * 100) / 100
    }
  };
}

/**
 * Quick validation function for simple use cases
 */
export function isValidDataset(data: TrainingExample[]): boolean {
  return validateDataset(data).valid;
}

/**
 * Filters out invalid examples from a dataset
 */
export function filterValidExamples(data: TrainingExample[]): TrainingExample[] {
  const result = validateDataset(data);
  return data.filter((_, index) => {
    return !result.errors.some(error => error.exampleIndex === index);
  });
}

/**
 * Generates a validation report as a formatted string
 */
export function generateValidationReport(result: ValidationResult): string {
  const lines: string[] = [];

  lines.push('=== Dataset Validation Report ===');
  lines.push(`Total Examples: ${result.stats.totalExamples}`);
  lines.push(`Valid Examples: ${result.stats.validExamples}`);
  lines.push(`Errors: ${result.stats.errorCount}`);
  lines.push(`Warnings: ${result.stats.warningCount}`);
  lines.push('');

  lines.push('Task Distribution:');
  Object.entries(result.stats.taskDistribution).forEach(([task, count]) => {
    lines.push(`  ${task}: ${count}`);
  });
  lines.push('');

  lines.push(`Average Input Length: ${result.stats.averageInputLength}`);
  lines.push(`Average Output Length: ${result.stats.averageOutputLength}`);
  lines.push('');

  if (result.errors.length > 0) {
    lines.push('Errors:');
    result.errors.forEach(error => {
      const index = error.exampleIndex !== undefined ? `[${error.exampleIndex}] ` : '';
      lines.push(`  ${index}${error.code}: ${error.message}`);
    });
    lines.push('');
  }

  if (result.warnings.length > 0) {
    lines.push('Warnings:');
    result.warnings.forEach(warning => {
      const index = warning.exampleIndex !== undefined ? `[${warning.exampleIndex}] ` : '';
      lines.push(`  ${index}${warning.code}: ${warning.message}`);
    });
    lines.push('');
  }

  lines.push(`Overall Status: ${result.valid ? 'VALID' : 'INVALID'}`);

  return lines.join('\n');
}
