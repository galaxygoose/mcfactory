// This file is generated by the Architect Agent.
// Other agents must implement logic INSIDE this file only.
// Do NOT create or delete files. Respect the MIC + MIM.

import { TrainingExample, TrainingExportConfig } from '../../types';
import { collectFromFactories } from './collectFromFactories';
import { generateLabels } from './labelGenerator';
import { formatJSONL } from './jsonlFormatter';
import { formatCSV } from './csvFormatter';
import { formatParquet } from './parquetFormatter';
import { manageShards, ShardConfig } from './shardManager';
import { generateEmbeddingsForExamples, EmbeddingConfig } from './embeddingGenerator';
import { validateDataset } from './datasetValidator';
import { generateManifest, updateManifestExports, TrainingManifest } from './trainingManifestGenerator';

/**
 * Export job configuration
 */
export interface ExportJob {
  id: string;
  name: string;
  schedule: 'manual' | 'daily' | 'weekly' | 'monthly';
  config: TrainingExportConfig;
  lastRun?: string;
  nextRun?: string;
  status: 'pending' | 'running' | 'completed' | 'failed';
  error?: string;
  stats?: {
    examplesProcessed: number;
    filesGenerated: number;
    duration: number;
  };
}

/**
 * Export result
 */
export interface ExportResult {
  success: boolean;
  jobId: string;
  files: string[];
  manifest: TrainingManifest;
  stats: {
    examplesProcessed: number;
    filesGenerated: number;
    duration: number;
    shardsCreated?: number;
  };
  error?: string;
}

/**
 * Scheduler configuration
 */
export interface SchedulerConfig {
  outputDir: string;
  maxConcurrentJobs?: number;
  defaultShardSize?: number;
  defaultFormat?: 'jsonl' | 'csv' | 'parquet' | 'hf';
  enableValidation?: boolean;
  enableEmbeddings?: boolean;
  enableSharding?: boolean;
}

/**
 * Global scheduler state
 */
class ExportScheduler {
  private jobs: Map<string, ExportJob> = new Map();
  private runningJobs: Set<string> = new Set();
  private config: SchedulerConfig;
  private intervalId?: NodeJS.Timeout;

  constructor(config: SchedulerConfig) {
    this.config = {
      maxConcurrentJobs: 3,
      defaultShardSize: 1000,
      defaultFormat: 'jsonl',
      enableValidation: true,
      enableEmbeddings: false,
      enableSharding: true,
      ...config
    };
  }

  /**
   * Schedules a new export job
   */
  scheduleExport(jobConfig: Omit<ExportJob, 'id' | 'status' | 'lastRun' | 'nextRun'>): string {
    const jobId = `job_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`;

    const job: ExportJob = {
      id: jobId,
      status: 'pending',
      nextRun: this.calculateNextRun(jobConfig.schedule),
      ...jobConfig
    };

    this.jobs.set(jobId, job);

    if (jobConfig.schedule === 'manual') {
      // For manual jobs, don't set up automatic scheduling
      return jobId;
    }

    // For scheduled jobs, update next run time
    this.updateJobSchedule(jobId);

    return jobId;
  }

  /**
   * Runs an export job immediately
   */
  async runExport(jobId: string): Promise<ExportResult> {
    const job = this.jobs.get(jobId);
    if (!job) {
      throw new Error(`Job ${jobId} not found`);
    }

    // Check if job is already running
    if (this.runningJobs.has(jobId)) {
      throw new Error(`Job ${jobId} is already running`);
    }

    // Check concurrent job limit
    if (this.runningJobs.size >= (this.config.maxConcurrentJobs || 3)) {
      throw new Error('Maximum concurrent jobs reached');
    }

    this.runningJobs.add(jobId);
    job.status = 'running';

    const startTime = Date.now();

    try {
      const result = await this.executeExport(job);

      job.status = 'completed';
      job.lastRun = new Date().toISOString();
      job.stats = {
        examplesProcessed: result.stats.examplesProcessed,
        filesGenerated: result.stats.filesGenerated,
        duration: result.stats.duration
      };

      // Update next run for recurring jobs
      if (job.schedule !== 'manual') {
        job.nextRun = this.calculateNextRun(job.schedule);
      }

      return result;
    } catch (error) {
      job.status = 'failed';
      job.error = error instanceof Error ? error.message : 'Unknown error';

      throw error;
    } finally {
      this.runningJobs.delete(jobId);
    }
  }

  /**
   * Executes the actual export process
   */
  private async executeExport(job: ExportJob): Promise<ExportResult> {
    const startTime = Date.now();
    const files: string[] = [];

    try {
      // 1. Collect training data from factories
      console.log(`[${job.id}] Collecting training data from factories...`);
      let examples = collectFromFactories();

      if (examples.length === 0) {
        throw new Error('No training examples collected from factories');
      }

      // 2. Generate labels
      console.log(`[${job.id}] Generating labels for ${examples.length} examples...`);
      examples = generateLabels(examples);

      // 3. Validate dataset (if enabled)
      if (this.config.enableValidation) {
        console.log(`[${job.id}] Validating dataset...`);
        const validationResult = validateDataset(examples);
        if (!validationResult.valid) {
          console.warn(`[${job.id}] Dataset validation failed:`, validationResult.errors);
          // Continue anyway, but log warnings
        }
      }

      // 4. Generate embeddings (if enabled)
      if (this.config.enableEmbeddings) {
        console.log(`[${job.id}] Generating embeddings...`);
        const embeddingConfig: EmbeddingConfig = {
          provider: 'openai',
          fields: ['input'],
          batchSize: 10
        };
        await generateEmbeddingsForExamples(examples, embeddingConfig);
      }

      // 5. Apply sharding (if enabled)
      let shardedData: any = examples;
      let shardInfo: { count: number; averageSize: number; strategy: string } | undefined;

      if (this.config.enableSharding && job.config.shardSize) {
        console.log(`[${job.id}] Applying sharding with size ${job.config.shardSize}...`);
        const shardConfig: ShardConfig = {
          maxShardSize: job.config.shardSize,
          strategy: 'round_robin'
        };
        shardedData = manageShards(examples, shardConfig);
        shardInfo = {
          count: shardedData.shards.length,
          averageSize: Math.round(examples.length / shardedData.shards.length),
          strategy: 'round_robin'
        };
      }

      // 6. Format and export data
      console.log(`[${job.id}] Formatting and exporting data in ${job.config.format} format...`);
      const exportFiles = await this.exportFormattedData(
        shardedData,
        job.config.format,
        job.id,
        this.config.outputDir
      );
      files.push(...exportFiles);

      // 7. Generate manifest
      console.log(`[${job.id}] Generating training manifest...`);
      const manifest = generateManifest(examples, {
        datasetId: `${job.name}_${Date.now()}`,
        description: `Auto-generated dataset from ${job.name}`,
        includeExamples: false
      });

      // Update manifest with export information
      const updatedManifest = updateManifestExports(manifest, [job.config.format], shardInfo);
      files.push(await this.saveManifest(updatedManifest, job.id, this.config.outputDir));

      const duration = Date.now() - startTime;

      const result: ExportResult = {
        success: true,
        jobId: job.id,
        files,
        manifest: updatedManifest,
        stats: {
          examplesProcessed: examples.length,
          filesGenerated: files.length,
          duration,
          shardsCreated: shardInfo?.count
        }
      };

      console.log(`[${job.id}] Export completed successfully in ${duration}ms`);
      return result;

    } catch (error) {
      const duration = Date.now() - startTime;
      console.error(`[${job.id}] Export failed after ${duration}ms:`, error);

      return {
        success: false,
        jobId: job.id,
        files,
        manifest: {} as TrainingManifest,
        stats: {
          examplesProcessed: 0,
          filesGenerated: files.length,
          duration
        },
        error: error instanceof Error ? error.message : 'Unknown export error'
      };
    }
  }

  /**
   * Exports data in the specified format
   */
  private async exportFormattedData(
    data: any,
    format: string,
    jobId: string,
    outputDir: string
  ): Promise<string[]> {
    const files: string[] = [];
    const timestamp = Date.now();

    // Handle sharded vs non-sharded data
    const examples = Array.isArray(data) ? data : data.shards.flat();
    const shards = Array.isArray(data) ? [data] : data.shards;

    for (let i = 0; i < shards.length; i++) {
      const shard = shards[i];
      const shardSuffix = shards.length > 1 ? `_shard_${i}` : '';

      let content: string;
      let filename: string;

      switch (format) {
        case 'jsonl':
          content = formatJSONL(shard);
          filename = `dataset_${timestamp}${shardSuffix}.jsonl`;
          break;

        case 'csv':
          content = formatCSV(shard);
          filename = `dataset_${timestamp}${shardSuffix}.csv`;
          break;

        case 'parquet':
          // For parquet, we'd normally write to a file, but since we can't,
          // we'll save the structured data as JSON for now
          const parquetData = formatParquet(shard);
          content = JSON.stringify(parquetData, null, 2);
          filename = `dataset_${timestamp}${shardSuffix}.parquet.json`;
          break;

        case 'hf':
          // Hugging Face format - similar to parquet but with specific structure
          const hfData = formatParquet(shard); // Reuse parquet logic
          content = JSON.stringify(hfData, null, 2);
          filename = `dataset_${timestamp}${shardSuffix}.hf.json`;
          break;

        default:
          throw new Error(`Unsupported format: ${format}`);
      }

      // In a real implementation, this would write to the filesystem
      // For now, we'll simulate the file creation
      const filePath = `${outputDir}/${filename}`;
      files.push(filePath);

      console.log(`[${jobId}] Generated file: ${filePath} (${content.length} bytes)`);
    }

    return files;
  }

  /**
   * Saves the manifest to a file
   */
  private async saveManifest(
    manifest: TrainingManifest,
    jobId: string,
    outputDir: string
  ): Promise<string> {
    const timestamp = Date.now();
    const filename = `manifest_${timestamp}.json`;
    const filePath = `${outputDir}/${filename}`;

    // In a real implementation, this would write to the filesystem
    console.log(`[${jobId}] Generated manifest: ${filePath}`);

    return filePath;
  }

  /**
   * Calculates the next run time for a scheduled job
   */
  private calculateNextRun(schedule: string): string {
    const now = new Date();

    switch (schedule) {
      case 'daily':
        const tomorrow = new Date(now);
        tomorrow.setDate(tomorrow.getDate() + 1);
        tomorrow.setHours(2, 0, 0, 0); // 2 AM tomorrow
        return tomorrow.toISOString();

      case 'weekly':
        const nextWeek = new Date(now);
        nextWeek.setDate(nextWeek.getDate() + (7 - now.getDay() + 1)); // Next Monday
        nextWeek.setHours(2, 0, 0, 0);
        return nextWeek.toISOString();

      case 'monthly':
        const nextMonth = new Date(now);
        nextMonth.setMonth(nextMonth.getMonth() + 1, 1); // 1st of next month
        nextMonth.setHours(2, 0, 0, 0);
        return nextMonth.toISOString();

      default:
        return '';
    }
  }

  /**
   * Updates the schedule for recurring jobs
   */
  private updateJobSchedule(jobId: string): void {
    const job = this.jobs.get(jobId);
    if (!job || job.schedule === 'manual') return;

    // In a real implementation, this would set up cron jobs or timers
    // For now, we'll just calculate the next run time
    job.nextRun = this.calculateNextRun(job.schedule);
  }

  /**
   * Starts the scheduler (for recurring jobs)
   */
  start(): void {
    if (this.intervalId) return; // Already started

    // Check for due jobs every minute
    this.intervalId = setInterval(() => {
      this.checkAndRunScheduledJobs();
    }, 60000);

    console.log('Export scheduler started');
  }

  /**
   * Stops the scheduler
   */
  stop(): void {
    if (this.intervalId) {
      clearInterval(this.intervalId);
      this.intervalId = undefined;
      console.log('Export scheduler stopped');
    }
  }

  /**
   * Checks for and runs scheduled jobs that are due
   */
  private async checkAndRunScheduledJobs(): Promise<void> {
    const now = new Date();

    for (const [jobId, job] of this.jobs) {
      if (job.schedule !== 'manual' &&
          job.status !== 'running' &&
          job.nextRun &&
          new Date(job.nextRun) <= now) {

        console.log(`Running scheduled job: ${job.name} (${jobId})`);
        try {
          await this.runExport(jobId);
        } catch (error) {
          console.error(`Scheduled job ${jobId} failed:`, error);
        }
      }
    }
  }

  /**
   * Gets all jobs
   */
  getJobs(): ExportJob[] {
    return Array.from(this.jobs.values());
  }

  /**
   * Gets a specific job by ID
   */
  getJob(jobId: string): ExportJob | undefined {
    return this.jobs.get(jobId);
  }

  /**
   * Cancels a job
   */
  cancelJob(jobId: string): boolean {
    const job = this.jobs.get(jobId);
    if (!job) return false;

    if (this.runningJobs.has(jobId)) {
      // Can't cancel a running job
      return false;
    }

    this.jobs.delete(jobId);
    return true;
  }

  /**
   * Gets scheduler statistics
   */
  getStats(): {
    totalJobs: number;
    runningJobs: number;
    completedJobs: number;
    failedJobs: number;
  } {
    const jobs = Array.from(this.jobs.values());
    return {
      totalJobs: jobs.length,
      runningJobs: this.runningJobs.size,
      completedJobs: jobs.filter(j => j.status === 'completed').length,
      failedJobs: jobs.filter(j => j.status === 'failed').length
    };
  }
}

// Global scheduler instance
let globalScheduler: ExportScheduler | null = null;

/**
 * Gets or creates the global scheduler instance
 */
export function getScheduler(config?: SchedulerConfig): ExportScheduler {
  if (!globalScheduler) {
    globalScheduler = new ExportScheduler(config || { outputDir: './exports' });
  }
  return globalScheduler;
}

/**
 * Schedules a new export job
 */
export function scheduleExport(
  name: string,
  schedule: 'manual' | 'daily' | 'weekly' | 'monthly',
  config: TrainingExportConfig
): string {
  const scheduler = getScheduler();
  return scheduler.scheduleExport({ name, schedule, config });
}

/**
 * Runs an export job immediately
 */
export function runExport(jobId: string): Promise<ExportResult> {
  const scheduler = getScheduler();
  return scheduler.runExport(jobId);
}

/**
 * Starts the export scheduler
 */
export function startScheduler(config?: SchedulerConfig): void {
  const scheduler = getScheduler(config);
  scheduler.start();
}

/**
 * Stops the export scheduler
 */
export function stopScheduler(): void {
  if (globalScheduler) {
    globalScheduler.stop();
  }
}

/**
 * Gets all scheduled jobs
 */
export function getScheduledJobs(): ExportJob[] {
  const scheduler = getScheduler();
  return scheduler.getJobs();
}

/**
 * Cancels a scheduled job
 */
export function cancelScheduledExport(jobId: string): boolean {
  const scheduler = getScheduler();
  return scheduler.cancelJob(jobId);
}
