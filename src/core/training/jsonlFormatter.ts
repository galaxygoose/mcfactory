// This file is generated by the Architect Agent.
// Other agents must implement logic INSIDE this file only.
// Do NOT create or delete files. Respect the MIC + MIM.

import { TrainingExample } from '../../types';

/**
 * Formats training examples into JSONL (JSON Lines) format
 * Each line contains a single JSON object representing a training example
 */
export function formatJSONL(data: TrainingExample[]): string {
  if (!Array.isArray(data) || data.length === 0) {
    return '';
  }

  return data
    .map(example => {
      try {
        // Validate and sanitize the example before formatting
        const sanitizedExample = sanitizeTrainingExample(example);

        // Convert to JSON string
        return JSON.stringify(sanitizedExample);
      } catch (error) {
        console.warn(`Failed to format training example: ${error}`);
        return null;
      }
    })
    .filter(line => line !== null)
    .join('\n');
}

/**
 * Sanitizes a training example to ensure it's valid for JSONL format
 * Removes circular references, handles special data types, and validates required fields
 */
function sanitizeTrainingExample(example: TrainingExample): Record<string, any> {
  if (!example || typeof example !== 'object') {
    throw new Error('Invalid training example: must be an object');
  }

  if (!example.input || typeof example.input !== 'string') {
    throw new Error('Invalid training example: input must be a non-empty string');
  }

  if (!example.task || typeof example.task !== 'string') {
    throw new Error('Invalid training example: task must be a non-empty string');
  }

  // Create a clean copy of the example
  const sanitized: Record<string, any> = {
    input: example.input.trim(),
    task: example.task.trim()
  };

  // Add output if present
  if (example.output !== undefined && example.output !== null) {
    sanitized.output = typeof example.output === 'string'
      ? example.output.trim()
      : example.output;
  }

  // Add metadata if present
  if (example.metadata && typeof example.metadata === 'object') {
    sanitized.metadata = sanitizeMetadata(example.metadata);
  }

  return sanitized;
}

/**
 * Sanitizes metadata object to ensure it's JSON-serializable
 * Handles special cases like dates, functions, and circular references
 */
function sanitizeMetadata(metadata: Record<string, any>): Record<string, any> {
  const sanitized: Record<string, any> = {};

  for (const [key, value] of Object.entries(metadata)) {
    try {
      // Skip functions and undefined values
      if (typeof value === 'function' || value === undefined) {
        continue;
      }

      // Handle Date objects
      if (value instanceof Date) {
        sanitized[key] = value.toISOString();
        continue;
      }

      // Handle arrays
      if (Array.isArray(value)) {
        sanitized[key] = value.map(item => {
          if (typeof item === 'function' || item === undefined) return null;
          if (item instanceof Date) return item.toISOString();
          return item;
        }).filter(item => item !== null);
        continue;
      }

      // Handle objects (shallow copy to avoid circular references)
      if (value !== null && typeof value === 'object' && !(value instanceof Date)) {
        // For simple objects, create a shallow copy
        // In a real implementation, you might want deeper sanitization
        sanitized[key] = { ...value };
        continue;
      }

      // Handle primitive values
      sanitized[key] = value;
    } catch (error) {
      // Skip problematic values
      console.warn(`Skipping metadata key '${key}' due to serialization error: ${error}`);
    }
  }

  return sanitized;
}

/**
 * Validates that the JSONL output is properly formatted
 * This is useful for debugging and ensuring data integrity
 */
export function validateJSONL(jsonlString: string): { valid: boolean; errors: string[] } {
  const errors: string[] = [];
  const lines = jsonlString.trim().split('\n');

  if (lines.length === 0) {
    return { valid: false, errors: ['JSONL string is empty'] };
  }

  lines.forEach((line, index) => {
    if (!line.trim()) {
      errors.push(`Line ${index + 1}: Empty line`);
      return;
    }

    try {
      const parsed = JSON.parse(line);

      // Validate required fields
      if (!parsed.input || typeof parsed.input !== 'string') {
        errors.push(`Line ${index + 1}: Missing or invalid 'input' field`);
      }

      if (!parsed.task || typeof parsed.task !== 'string') {
        errors.push(`Line ${index + 1}: Missing or invalid 'task' field`);
      }

      // Validate metadata if present
      if (parsed.metadata && typeof parsed.metadata !== 'object') {
        errors.push(`Line ${index + 1}: Invalid 'metadata' field - must be an object`);
      }
    } catch (parseError) {
      errors.push(`Line ${index + 1}: Invalid JSON - ${parseError}`);
    }
  });

  return {
    valid: errors.length === 0,
    errors
  };
}

/**
 * Parses JSONL string back into TrainingExample array
 * Useful for loading previously formatted data
 */
export function parseJSONL(jsonlString: string): TrainingExample[] {
  if (!jsonlString || typeof jsonlString !== 'string') {
    return [];
  }

  const lines = jsonlString.trim().split('\n');
  const examples: TrainingExample[] = [];

  lines.forEach((line, index) => {
    if (!line.trim()) return;

    try {
      const parsed = JSON.parse(line) as TrainingExample;
      examples.push(parsed);
    } catch (error) {
      console.warn(`Failed to parse JSONL line ${index + 1}: ${error}`);
    }
  });

  return examples;
}

/**
 * Estimates the size of the JSONL output in bytes
 * Useful for determining if sharding is needed
 */
export function estimateJSONLSize(data: TrainingExample[]): number {
  if (!Array.isArray(data) || data.length === 0) {
    return 0;
  }

  // Estimate based on a sample of the data
  const sampleSize = Math.min(data.length, 10);
  const sample = data.slice(0, sampleSize);
  const sampleJSONL = formatJSONL(sample);

  // Calculate average bytes per example from sample
  const avgBytesPerExample = sampleJSONL.length / sampleSize;

  // Estimate total size
  return Math.ceil(avgBytesPerExample * data.length);
}
