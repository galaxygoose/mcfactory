// This file is generated by the Architect Agent.
// Other agents must implement logic INSIDE this file only.
// Do NOT create or delete files. Respect the MIC + MIM.

import { TrainingExample } from '../../types';

/**
 * Generates and enhances labels for training examples based on their task type
 * This function analyzes the task and output to create standardized labels
 */
export function generateLabels(data: TrainingExample[]): TrainingExample[] {
  return data.map(example => generateLabelForExample(example));
}

/**
 * Generate a label for a single training example based on its task type
 */
function generateLabelForExample(example: TrainingExample): TrainingExample {
  const enhancedExample = { ...example };

  // Add label field based on task type
  enhancedExample.metadata = {
    ...enhancedExample.metadata,
    label: generateTaskSpecificLabel(example),
    labelType: getLabelType(example.task),
    confidence: calculateLabelConfidence(example)
  };

  return enhancedExample;
}

/**
 * Generate task-specific labels based on the example's task and output
 */
function generateTaskSpecificLabel(example: TrainingExample): string {
  switch (example.task) {
    case 'translation':
      return generateTranslationLabel(example);

    case 'moderation':
      return generateModerationLabel(example);

    case 'ai_detection':
      return generateAIDetectionLabel(example);

    case 'voice_detection':
      return generateVoiceDetectionLabel(example);

    case 'summarization':
      return generateSummarizationLabel(example);

    case 'sentiment_analysis':
      return generateSentimentLabel(example);

    case 'categorization':
      return generateCategorizationLabel(example);

    default:
      return example.output || 'unknown';
  }
}

/**
 * Generate label for translation tasks
 */
function generateTranslationLabel(example: TrainingExample): string {
  if (!example.output) return 'translation_failed';

  const output = typeof example.output === 'string' ? example.output : JSON.stringify(example.output);
  const sourceLang = example.metadata?.sourceLang || 'unknown';
  const targetLang = example.metadata?.targetLang || 'unknown';

  // Create a classification label for translation quality
  const quality = assessTranslationQuality(example);
  return `translation_${sourceLang}_${targetLang}_${quality}`;
}

/**
 * Generate label for moderation tasks
 */
function generateModerationLabel(example: TrainingExample): string {
  try {
    const output = typeof example.output === 'string' ? JSON.parse(example.output) : example.output;

    if (output.safe) {
      return 'safe_content';
    } else {
      const primaryCategory = output.categories?.[0] || 'unsafe';
      return `unsafe_${primaryCategory}`;
    }
  } catch {
    return 'moderation_error';
  }
}

/**
 * Generate label for AI detection tasks
 */
function generateAIDetectionLabel(example: TrainingExample): string {
  try {
    const output = typeof example.output === 'string' ? JSON.parse(example.output) : example.output;

    if (output.isAI) {
      const confidence = output.confidence || 0;
      if (confidence > 0.8) return 'high_confidence_ai';
      if (confidence > 0.6) return 'medium_confidence_ai';
      return 'low_confidence_ai';
    } else {
      const confidence = output.confidence || 0;
      if (confidence < 0.2) return 'high_confidence_human';
      if (confidence < 0.4) return 'medium_confidence_human';
      return 'low_confidence_human';
    }
  } catch {
    return 'detection_error';
  }
}

/**
 * Generate label for voice detection tasks
 */
function generateVoiceDetectionLabel(example: TrainingExample): string {
  try {
    const output = typeof example.output === 'string' ? JSON.parse(example.output) : example.output;

    if (output.isFake) {
      return 'synthetic_voice';
    } else {
      return 'human_voice';
    }
  } catch {
    return 'voice_detection_error';
  }
}

/**
 * Generate label for summarization tasks
 */
function generateSummarizationLabel(example: TrainingExample): string {
  if (!example.output) return 'summarization_failed';

  const summaryLength = example.metadata?.summaryLength || 'medium';
  const inputLength = example.input?.length || 0;

  // Classify summary based on compression ratio
  const compressionRatio = inputLength > 0 ? (example.output.length / inputLength) : 1;

  if (compressionRatio < 0.2) return `summary_${summaryLength}_high_compression`;
  if (compressionRatio < 0.4) return `summary_${summaryLength}_medium_compression`;
  return `summary_${summaryLength}_low_compression`;
}

/**
 * Generate label for sentiment analysis tasks
 */
function generateSentimentLabel(example: TrainingExample): string {
  try {
    const output = typeof example.output === 'string' ? JSON.parse(example.output) : example.output;
    const label = output.label || 'neutral';
    const score = output.score || 0;

    // Add confidence prefix
    if (score > 0.8) return `high_confidence_${label}`;
    if (score > 0.6) return `medium_confidence_${label}`;
    return `low_confidence_${label}`;
  } catch {
    return 'sentiment_error';
  }
}

/**
 * Generate label for categorization tasks
 */
function generateCategorizationLabel(example: TrainingExample): string {
  try {
    const output = typeof example.output === 'string' ? JSON.parse(example.output) : example.output;

    if (output.category) {
      return `category_${output.category.toLowerCase().replace(/\s+/g, '_')}`;
    }

    if (output.tags && output.tags.length > 0) {
      return `tags_${output.tags[0].toLowerCase().replace(/\s+/g, '_')}`;
    }

    return 'uncategorized';
  } catch {
    return 'categorization_error';
  }
}

/**
 * Get the type of label for a given task
 */
function getLabelType(task: string): string {
  switch (task) {
    case 'translation':
    case 'summarization':
      return 'generation';

    case 'moderation':
    case 'ai_detection':
    case 'voice_detection':
    case 'sentiment_analysis':
      return 'classification';

    case 'categorization':
      return 'tagging';

    default:
      return 'unknown';
  }
}

/**
 * Calculate confidence score for the generated label
 */
function calculateLabelConfidence(example: TrainingExample): number {
  // Extract confidence from various sources
  if (example.metadata?.confidence !== undefined) {
    return example.metadata.confidence;
  }

  // Try to parse from output
  try {
    const output = typeof example.output === 'string' ? JSON.parse(example.output) : example.output;
    if (typeof output.confidence === 'number') {
      return output.confidence;
    }
    if (typeof output.score === 'number') {
      return output.score;
    }
  } catch {
    // Ignore parsing errors
  }

  // Default confidence based on task type
  switch (example.task) {
    case 'moderation':
    case 'ai_detection':
    case 'voice_detection':
    case 'sentiment_analysis':
      return 0.8; // Classification tasks typically have higher confidence

    case 'translation':
    case 'summarization':
    case 'categorization':
      return 0.7; // Generation tasks have slightly lower confidence

    default:
      return 0.5; // Unknown tasks get medium confidence
  }
}

/**
 * Assess the quality of a translation based on various heuristics
 */
function assessTranslationQuality(example: TrainingExample): string {
  if (!example.output) return 'failed';

  const output = typeof example.output === 'string' ? example.output : JSON.stringify(example.output);

  // Simple quality assessment based on output characteristics
  const hasExpectedStructure = output.length > 10;
  const hasProperPunctuation = /[.!?]$/.test(output.trim());
  const hasReasonableLength = output.length > 5 && output.length < 200;

  if (hasExpectedStructure && hasProperPunctuation && hasReasonableLength) {
    return 'good';
  } else if (hasExpectedStructure) {
    return 'acceptable';
  } else {
    return 'poor';
  }
}
