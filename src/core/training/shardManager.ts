// This file is generated by the Architect Agent.
// Other agents must implement logic INSIDE this file only.
// Do NOT create or delete files. Respect the MIC + MIM.

import { TrainingExample } from '../../types';

/**
 * Shard configuration options
 */
export interface ShardConfig {
  maxShardSize: number; // Maximum examples per shard
  strategy?: 'round_robin' | 'by_task' | 'balanced' | 'random';
  balanceBy?: 'task' | 'size' | 'random';
  preserveOrder?: boolean; // Whether to preserve original order within shards
}

/**
 * Shard metadata
 */
export interface ShardMetadata {
  shardIndex: number;
  totalShards: number;
  exampleCount: number;
  taskDistribution: Record<string, number>;
  sizeBytes: number;
  created: string;
}

/**
 * Sharded dataset result
 */
export interface ShardedDataset {
  shards: TrainingExample[][];
  metadata: ShardMetadata[];
  config: ShardConfig;
}

/**
 * Manages dataset sharding by splitting training examples into manageable chunks
 * Supports different sharding strategies for optimal training performance
 */
export function manageShards(data: TrainingExample[], config: ShardConfig): ShardedDataset;
export function manageShards(data: TrainingExample[], shardSize: number): TrainingExample[][];
export function manageShards(
  data: TrainingExample[],
  configOrSize: ShardConfig | number
): ShardedDataset | TrainingExample[][] {
  if (typeof configOrSize === 'number') {
    // Legacy API support
    const config: ShardConfig = {
      maxShardSize: configOrSize,
      strategy: 'round_robin',
      preserveOrder: true
    };
    const result = createShards(data, config);
    return result.shards;
  }

  return createShards(data, configOrSize);
}

/**
 * Creates shards based on the provided configuration
 */
function createShards(data: TrainingExample[], config: ShardConfig): ShardedDataset {
  if (!Array.isArray(data) || data.length === 0) {
    return {
      shards: [],
      metadata: [],
      config
    };
  }

  let shards: TrainingExample[][];

  switch (config.strategy) {
    case 'by_task':
      shards = shardByTask(data, config);
      break;
    case 'balanced':
      shards = shardBalanced(data, config);
      break;
    case 'random':
      shards = shardRandom(data, config);
      break;
    case 'round_robin':
    default:
      shards = shardRoundRobin(data, config);
      break;
  }

  // Generate metadata for each shard
  const metadata = shards.map((shard, index) => generateShardMetadata(shard, index, shards.length));

  return {
    shards,
    metadata,
    config
  };
}

/**
 * Shards data using round-robin distribution
 * Distributes examples sequentially across shards
 */
function shardRoundRobin(data: TrainingExample[], config: ShardConfig): TrainingExample[][] {
  const shardCount = Math.ceil(data.length / config.maxShardSize);
  const shards: TrainingExample[][] = Array.from({ length: shardCount }, () => []);

  data.forEach((example, index) => {
    const shardIndex = index % shardCount;
    shards[shardIndex].push(example);
  });

  return shards;
}

/**
 * Shards data by grouping examples with the same task together
 * Useful for task-specific fine-tuning
 */
function shardByTask(data: TrainingExample[], config: ShardConfig): TrainingExample[][] {
  const taskGroups = new Map<string, TrainingExample[]>();

  // Group examples by task
  data.forEach(example => {
    const task = example.task;
    if (!taskGroups.has(task)) {
      taskGroups.set(task, []);
    }
    taskGroups.get(task)!.push(example);
  });

  const shards: TrainingExample[][] = [];
  const tasks = Array.from(taskGroups.keys());

  // Distribute task groups across shards
  tasks.forEach(task => {
    const taskExamples = taskGroups.get(task)!;

    // If task group is larger than shard size, split it
    if (taskExamples.length > config.maxShardSize) {
      const taskShards = splitLargeTaskGroup(taskExamples, config.maxShardSize);
      shards.push(...taskShards);
    } else {
      // Find a shard that can accommodate this task group
      let placed = false;
      for (const shard of shards) {
        if (shard.length + taskExamples.length <= config.maxShardSize) {
          shard.push(...taskExamples);
          placed = true;
          break;
        }
      }

      // If no existing shard can take it, create a new one
      if (!placed) {
        shards.push([...taskExamples]);
      }
    }
  });

  return shards;
}

/**
 * Creates balanced shards by distributing examples to minimize variance
 * in shard sizes and task distributions
 */
function shardBalanced(data: TrainingExample[], config: ShardConfig): TrainingExample[][] {
  const shardCount = Math.ceil(data.length / config.maxShardSize);
  const shards: TrainingExample[][] = Array.from({ length: shardCount }, () => []);

  // Sort data based on balance criteria
  let sortedData = [...data];
  if (config.balanceBy === 'task') {
    sortedData.sort((a, b) => a.task.localeCompare(b.task));
  } else if (config.balanceBy === 'size') {
    sortedData.sort((a, b) => (a.input?.length || 0) - (b.input?.length || 0));
  }

  // Distribute examples to maintain balance
  sortedData.forEach(example => {
    // Find the shard with the smallest current size
    let smallestShardIndex = 0;
    let smallestSize = shards[0].length;

    for (let i = 1; i < shards.length; i++) {
      if (shards[i].length < smallestSize) {
        smallestSize = shards[i].length;
        smallestShardIndex = i;
      }
    }

    shards[smallestShardIndex].push(example);
  });

  return shards;
}

/**
 * Shards data randomly for unbiased distribution
 */
function shardRandom(data: TrainingExample[], config: ShardConfig): TrainingExample[][] {
  const shuffled = [...data];

  // Fisher-Yates shuffle
  for (let i = shuffled.length - 1; i > 0; i--) {
    const j = Math.floor(Math.random() * (i + 1));
    [shuffled[i], shuffled[j]] = [shuffled[j], shuffled[i]];
  }

  return shardRoundRobin(shuffled, config);
}

/**
 * Splits a large task group into smaller shards
 */
function splitLargeTaskGroup(examples: TrainingExample[], maxShardSize: number): TrainingExample[][] {
  const shards: TrainingExample[][] = [];

  for (let i = 0; i < examples.length; i += maxShardSize) {
    shards.push(examples.slice(i, i + maxShardSize));
  }

  return shards;
}

/**
 * Generates metadata for a shard
 */
function generateShardMetadata(
  shard: TrainingExample[],
  shardIndex: number,
  totalShards: number
): ShardMetadata {
  const taskDistribution: Record<string, number> = {};

  // Count tasks in this shard
  shard.forEach(example => {
    taskDistribution[example.task] = (taskDistribution[example.task] || 0) + 1;
  });

  // Estimate size in bytes (rough calculation)
  const sizeBytes = shard.reduce((total, example) => {
    return total +
      (example.input?.length || 0) +
      (example.output?.length || 0) +
      (example.task?.length || 0) +
      JSON.stringify(example.metadata || {}).length;
  }, 0);

  return {
    shardIndex,
    totalShards,
    exampleCount: shard.length,
    taskDistribution,
    sizeBytes,
    created: new Date().toISOString()
  };
}

/**
 * Merges multiple shards back into a single dataset
 * Useful for loading sharded data
 */
export function mergeShards(shardedDataset: ShardedDataset): TrainingExample[] {
  return shardedDataset.shards.flat();
}

/**
 * Validates shard integrity and consistency
 */
export function validateShards(shardedDataset: ShardedDataset): { valid: boolean; errors: string[] } {
  const errors: string[] = [];

  if (!Array.isArray(shardedDataset.shards)) {
    errors.push('Invalid sharded dataset: shards must be an array');
    return { valid: false, errors };
  }

  if (!Array.isArray(shardedDataset.metadata)) {
    errors.push('Invalid sharded dataset: metadata must be an array');
    return { valid: false, errors };
  }

  if (shardedDataset.shards.length !== shardedDataset.metadata.length) {
    errors.push('Shard count mismatch between shards and metadata arrays');
  }

  // Validate each shard
  shardedDataset.shards.forEach((shard, index) => {
    if (!Array.isArray(shard)) {
      errors.push(`Shard ${index}: must be an array of training examples`);
      return;
    }

    // Check shard size against config
    if (shard.length > shardedDataset.config.maxShardSize) {
      errors.push(`Shard ${index}: size ${shard.length} exceeds max shard size ${shardedDataset.config.maxShardSize}`);
    }

    // Validate metadata consistency
    const metadata = shardedDataset.metadata[index];
    if (metadata && metadata.exampleCount !== shard.length) {
      errors.push(`Shard ${index}: metadata example count ${metadata.exampleCount} doesn't match actual count ${shard.length}`);
    }

    // Validate examples in shard
    shard.forEach((example, exampleIndex) => {
      if (!example.input || typeof example.input !== 'string') {
        errors.push(`Shard ${index}, Example ${exampleIndex}: missing or invalid input field`);
      }
      if (!example.task || typeof example.task !== 'string') {
        errors.push(`Shard ${index}, Example ${exampleIndex}: missing or invalid task field`);
      }
    });
  });

  return {
    valid: errors.length === 0,
    errors
  };
}

/**
 * Optimizes shard configuration based on dataset characteristics
 * Suggests optimal shard sizes and strategies
 */
export function optimizeShardConfig(
  data: TrainingExample[],
  targetShardSize?: number
): ShardConfig {
  const totalExamples = data.length;
  const uniqueTasks = new Set(data.map(ex => ex.task)).size;

  // Calculate average example size
  const avgExampleSize = data.reduce((sum, ex) => {
    return sum + (ex.input?.length || 0) + (ex.output?.length || 0);
  }, 0) / totalExamples;

  let recommendedStrategy: ShardConfig['strategy'] = 'round_robin';
  let recommendedShardSize = targetShardSize || 1000;

  // Choose strategy based on dataset characteristics
  if (uniqueTasks > 10 && totalExamples > 10000) {
    // Many tasks and large dataset - use balanced sharding
    recommendedStrategy = 'balanced';
    recommendedShardSize = Math.max(500, Math.min(2000, Math.floor(totalExamples / uniqueTasks)));
  } else if (uniqueTasks <= 5) {
    // Few tasks - group by task for focused training
    recommendedStrategy = 'by_task';
    recommendedShardSize = Math.max(1000, Math.floor(totalExamples / 10));
  } else {
    // Default round-robin for general cases
    recommendedStrategy = 'round_robin';
    recommendedShardSize = Math.max(500, Math.min(5000, Math.floor(totalExamples / 20)));
  }

  return {
    maxShardSize: recommendedShardSize,
    strategy: recommendedStrategy,
    balanceBy: uniqueTasks > 5 ? 'task' : 'size',
    preserveOrder: true
  };
}
