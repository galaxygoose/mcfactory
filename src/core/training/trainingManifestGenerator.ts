// This file is generated by the Architect Agent.
// Other agents must implement logic INSIDE this file only.
// Do NOT create or delete files. Respect the MIC + MIM.

import { TrainingExample } from '../../types';

/**
 * Training manifest that describes a dataset
 */
export interface TrainingManifest {
  // Basic metadata
  version: string;
  datasetId: string;
  created: string;
  description?: string;

  // Dataset statistics
  statistics: {
    totalExamples: number;
    totalTasks: number;
    taskDistribution: Record<string, number>;
    averageInputLength: number;
    averageOutputLength: number;
    hasOutputs: boolean;
    outputCoverage: number; // Percentage of examples with outputs
  };

  // Schema information
  schema: {
    fields: ManifestField[];
    requiredFields: string[];
    optionalFields: string[];
  };

  // Quality metrics
  quality: {
    validationPassed: boolean;
    errorCount: number;
    warningCount: number;
    duplicateCount: number;
    completenessScore: number; // 0-1 score of data completeness
  };

  // Data characteristics
  characteristics: {
    languages?: string[];
    domains?: string[];
    difficulty?: 'easy' | 'medium' | 'hard' | 'mixed';
    contentTypes?: string[];
    temporalRange?: {
      earliest?: string;
      latest?: string;
    };
  };

  // Processing metadata
  processing: {
    sourceFactories: string[];
    transformations: string[];
    lastProcessed: string;
    processingDuration?: number;
  };

  // Export information
  exports?: {
    formats: string[];
    shards?: {
      count: number;
      averageSize: number;
      strategy: string;
    };
    lastExport?: string;
    exportCount: number;
  };

  // Custom metadata
  metadata?: Record<string, any>;
}

/**
 * Field description in the manifest
 */
export interface ManifestField {
  name: string;
  type: 'string' | 'number' | 'boolean' | 'array' | 'object';
  nullable: boolean;
  description?: string;
  examples?: any[];
  statistics?: {
    minLength?: number;
    maxLength?: number;
    averageLength?: number;
    uniqueValues?: number;
    mostCommonValues?: Array<{ value: any; count: number }>;
  };
}

/**
 * Configuration for manifest generation
 */
export interface ManifestConfig {
  datasetId?: string;
  description?: string;
  includeExamples?: boolean; // Whether to include example values in field descriptions
  customMetadata?: Record<string, any>;
  qualityThresholds?: {
    minCompleteness?: number;
    maxErrorRate?: number;
  };
}

/**
 * Generates a comprehensive training manifest for a dataset
 */
export function generateManifest(
  data: TrainingExample[],
  config: ManifestConfig = {}
): TrainingManifest {
  const {
    datasetId = `dataset_${Date.now()}`,
    description,
    includeExamples = false,
    customMetadata = {},
    qualityThresholds = { minCompleteness: 0.8, maxErrorRate: 0.05 }
  } = config;

  const startTime = Date.now();

  // Basic dataset analysis
  const statistics = analyzeDatasetStatistics(data);
  const schema = inferDatasetSchema(data, includeExamples);
  const quality = assessDatasetQuality(data, {
    minCompleteness: qualityThresholds.minCompleteness ?? 0.8,
    maxErrorRate: qualityThresholds.maxErrorRate ?? 0.05
  });
  const characteristics = inferDatasetCharacteristics(data);
  const processing = generateProcessingMetadata();

  const manifest: TrainingManifest = {
    version: '1.0.0',
    datasetId,
    created: new Date().toISOString(),
    description,
    statistics,
    schema,
    quality,
    characteristics,
    processing,
    exports: {
      formats: [],
      exportCount: 0
    },
    metadata: customMetadata
  };

  // Update processing duration
  manifest.processing.processingDuration = Date.now() - startTime;

  return manifest;
}

/**
 * Analyzes basic statistics of the dataset
 */
function analyzeDatasetStatistics(data: TrainingExample[]): TrainingManifest['statistics'] {
  const taskDistribution: Record<string, number> = {};
  let totalInputLength = 0;
  let totalOutputLength = 0;
  let examplesWithOutputs = 0;

  data.forEach(example => {
    // Count tasks
    taskDistribution[example.task] = (taskDistribution[example.task] || 0) + 1;

    // Calculate lengths
    if (example.input) {
      totalInputLength += example.input.length;
    }

    if (example.output) {
      totalOutputLength += example.output.length;
      examplesWithOutputs++;
    }
  });

  const totalExamples = data.length;
  const totalTasks = Object.keys(taskDistribution).length;

  return {
    totalExamples,
    totalTasks,
    taskDistribution,
    averageInputLength: totalExamples > 0 ? Math.round(totalInputLength / totalExamples) : 0,
    averageOutputLength: examplesWithOutputs > 0 ? Math.round(totalOutputLength / examplesWithOutputs) : 0,
    hasOutputs: examplesWithOutputs > 0,
    outputCoverage: totalExamples > 0 ? examplesWithOutputs / totalExamples : 0
  };
}

/**
 * Infers the schema from the dataset
 */
function inferDatasetSchema(data: TrainingExample[], includeExamples: boolean): TrainingManifest['schema'] {
  const fields = new Map<string, ManifestField>();
  const fieldValues = new Map<string, Set<any>>();

  // Analyze all examples to build field information
  data.forEach(example => {
    analyzeExampleFields(example, fields, fieldValues, includeExamples);
  });

  // Convert to final schema format
  const schemaFields = Array.from(fields.values()).map(field => {
    const values = fieldValues.get(field.name);
    if (values && field.type === 'string') {
      field.statistics = calculateFieldStatistics(values, field.name);
    }
    return field;
  });

  const requiredFields = schemaFields
    .filter(field => !field.nullable)
    .map(field => field.name);

  const optionalFields = schemaFields
    .filter(field => field.nullable)
    .map(field => field.name);

  return {
    fields: schemaFields,
    requiredFields,
    optionalFields
  };
}

/**
 * Analyzes fields in a single example
 */
function analyzeExampleFields(
  example: TrainingExample,
  fields: Map<string, ManifestField>,
  fieldValues: Map<string, Set<any>>,
  includeExamples: boolean
): void {
  // Core fields
  const coreFields = [
    { name: 'input', value: example.input, nullable: false },
    { name: 'output', value: example.output, nullable: true },
    { name: 'task', value: example.task, nullable: false }
  ];

  coreFields.forEach(({ name, value, nullable }) => {
    if (!fields.has(name)) {
      fields.set(name, {
        name,
        type: inferFieldType(value),
        nullable,
        description: getFieldDescription(name),
        examples: includeExamples ? [] : undefined
      });
    }

    if (includeExamples && fields.get(name)?.examples && value !== undefined) {
      const examples = fields.get(name)!.examples!;
      if (examples.length < 3) { // Limit to 3 examples per field
        examples.push(value);
      }
    }

    // Track unique values for statistics
    if (!fieldValues.has(name)) {
      fieldValues.set(name, new Set());
    }
    if (value !== undefined) {
      fieldValues.get(name)!.add(value);
    }
  });

  // Metadata fields
  if (example.metadata) {
    Object.entries(example.metadata).forEach(([key, value]) => {
      const fullKey = `metadata.${key}`;
      if (!fields.has(fullKey)) {
        fields.set(fullKey, {
          name: fullKey,
          type: inferFieldType(value),
          nullable: true,
          description: `Metadata field: ${key}`,
          examples: includeExamples ? [] : undefined
        });
      }

      if (includeExamples && fields.get(fullKey)?.examples && value !== undefined) {
        const examples = fields.get(fullKey)!.examples!;
        if (examples.length < 3) {
          examples.push(value);
        }
      }

      // Track unique values
      if (!fieldValues.has(fullKey)) {
        fieldValues.set(fullKey, new Set());
      }
      if (value !== undefined) {
        fieldValues.get(fullKey)!.add(value);
      }
    });
  }
}

/**
 * Infers the type of a field value
 */
function inferFieldType(value: any): ManifestField['type'] {
  if (value === null || value === undefined) return 'string';

  if (typeof value === 'string') return 'string';
  if (typeof value === 'number') return 'number';
  if (typeof value === 'boolean') return 'boolean';
  if (Array.isArray(value)) return 'array';
  if (typeof value === 'object') return 'object';

  return 'string'; // Default fallback
}

/**
 * Gets a human-readable description for a field
 */
function getFieldDescription(fieldName: string): string {
  const descriptions: Record<string, string> = {
    input: 'The input text or prompt for the training example',
    output: 'The expected output or response for the training example',
    task: 'The type of task this example represents (e.g., translation, summarization)',
    'metadata.confidence': 'Confidence score for the example or prediction',
    'metadata.label': 'Generated or assigned label for the example',
    'metadata.provider': 'The AI provider used to generate this example',
    'metadata.tokens': 'Number of tokens used in processing',
    'metadata.factory': 'The factory that produced this example'
  };

  return descriptions[fieldName] || `Field: ${fieldName}`;
}

/**
 * Calculates statistics for a field based on its values
 */
function calculateFieldStatistics(values: Set<any>, fieldName: string): ManifestField['statistics'] {
  const valueArray = Array.from(values);
  const stats: ManifestField['statistics'] = {
    uniqueValues: valueArray.length
  };

  if (fieldName === 'input' || fieldName === 'output' || fieldName.includes('metadata.')) {
    const stringValues = valueArray.filter(v => typeof v === 'string') as string[];
    if (stringValues.length > 0) {
      stats.minLength = Math.min(...stringValues.map(s => s.length));
      stats.maxLength = Math.max(...stringValues.map(s => s.length));
      stats.averageLength = Math.round(stringValues.reduce((sum, s) => sum + s.length, 0) / stringValues.length);
    }
  }

  // Most common values (top 5)
  if (valueArray.length > 0) {
    const valueCounts = new Map<any, number>();
    valueArray.forEach(value => {
      valueCounts.set(value, (valueCounts.get(value) || 0) + 1);
    });

    const sortedValues = Array.from(valueCounts.entries())
      .sort((a, b) => b[1] - a[1])
      .slice(0, 5)
      .map(([value, count]) => ({ value, count }));

    stats.mostCommonValues = sortedValues;
  }

  return stats;
}

/**
 * Assesses the quality of the dataset
 */
function assessDatasetQuality(
  data: TrainingExample[],
  thresholds: { minCompleteness: number; maxErrorRate: number }
): TrainingManifest['quality'] {
  let errorCount = 0;
  let warningCount = 0;
  let duplicateCount = 0;

  // Simple validation checks
  const seen = new Set<string>();
  data.forEach(example => {
    // Check required fields
    if (!example.input || !example.task) {
      errorCount++;
    }

    // Check for duplicates (simple hash-based)
    const hash = `${example.input || ''}|${example.output || ''}|${example.task || ''}`;
    if (seen.has(hash)) {
      duplicateCount++;
    } else {
      seen.add(hash);
    }

    // Check for potential issues
    if (example.input && example.input.length < 10) {
      warningCount++;
    }
  });

  const totalExamples = data.length;
  const errorRate = totalExamples > 0 ? errorCount / totalExamples : 0;
  const completenessScore = calculateCompletenessScore(data);

  const validationPassed = errorRate <= thresholds.maxErrorRate &&
                          completenessScore >= thresholds.minCompleteness;

  return {
    validationPassed,
    errorCount,
    warningCount,
    duplicateCount,
    completenessScore
  };
}

/**
 * Calculates a completeness score for the dataset
 */
function calculateCompletenessScore(data: TrainingExample[]): number {
  if (data.length === 0) return 0;

  let totalScore = 0;
  let maxScore = 0;

  data.forEach(example => {
    maxScore += 4; // input, task, output (optional), metadata (optional)

    // Required fields
    if (example.input && example.input.trim()) totalScore += 1;
    if (example.task && example.task.trim()) totalScore += 1;

    // Optional but valuable fields
    if (example.output && example.output.trim()) totalScore += 1;
    if (example.metadata && Object.keys(example.metadata).length > 0) totalScore += 1;
  });

  return maxScore > 0 ? totalScore / maxScore : 0;
}

/**
 * Infers characteristics of the dataset
 */
function inferDatasetCharacteristics(data: TrainingExample[]): TrainingManifest['characteristics'] {
  const characteristics: TrainingManifest['characteristics'] = {};

  // Infer languages from task types
  const languages = new Set<string>();
  const domains = new Set<string>();
  const contentTypes = new Set<string>();

  data.forEach(example => {
    // Extract language info from tasks
    if (example.task.includes('translation')) {
      if (example.metadata?.sourceLang) languages.add(example.metadata.sourceLang);
      if (example.metadata?.targetLang) languages.add(example.metadata.targetLang);
    }

    // Extract domains from metadata
    if (example.metadata?.domain) {
      domains.add(example.metadata.domain);
    }

    // Extract content types from tasks
    if (example.task.includes('sentiment')) contentTypes.add('sentiment');
    else if (example.task.includes('summarization')) contentTypes.add('summarization');
    else if (example.task.includes('translation')) contentTypes.add('translation');
    else if (example.task.includes('moderation')) contentTypes.add('moderation');
    else if (example.task.includes('detection')) contentTypes.add('detection');
  });

  if (languages.size > 0) characteristics.languages = Array.from(languages);
  if (domains.size > 0) characteristics.domains = Array.from(domains);
  if (contentTypes.size > 0) characteristics.contentTypes = Array.from(contentTypes);

  // Infer difficulty (very basic heuristic)
  const avgInputLength = data.reduce((sum, ex) => sum + (ex.input?.length || 0), 0) / data.length;
  if (avgInputLength < 50) characteristics.difficulty = 'easy';
  else if (avgInputLength < 200) characteristics.difficulty = 'medium';
  else characteristics.difficulty = 'hard';

  return characteristics;
}

/**
 * Generates processing metadata
 */
function generateProcessingMetadata(): TrainingManifest['processing'] {
  return {
    sourceFactories: ['TranslationFactory', 'ModerationFactory', 'DetectionFactory', 'AgentFactory'],
    transformations: ['labelGeneration', 'embeddingGeneration', 'sharding'],
    lastProcessed: new Date().toISOString()
  };
}

/**
 * Updates export information in the manifest
 */
export function updateManifestExports(
  manifest: TrainingManifest,
  formats: string[],
  shards?: { count: number; averageSize: number; strategy: string }
): TrainingManifest {
  const updatedManifest = { ...manifest };

  updatedManifest.exports = {
    formats: [...new Set([...(manifest.exports?.formats || []), ...formats])],
    shards,
    lastExport: new Date().toISOString(),
    exportCount: (manifest.exports?.exportCount || 0) + 1
  };

  return updatedManifest;
}

/**
 * Validates a manifest for completeness and correctness
 */
export function validateManifest(manifest: TrainingManifest): { valid: boolean; errors: string[] } {
  const errors: string[] = [];

  if (!manifest.version) errors.push('Missing version');
  if (!manifest.datasetId) errors.push('Missing datasetId');
  if (!manifest.created) errors.push('Missing created timestamp');

  if (!manifest.statistics) errors.push('Missing statistics');
  else {
    if (typeof manifest.statistics.totalExamples !== 'number') {
      errors.push('Invalid totalExamples in statistics');
    }
  }

  if (!manifest.schema) errors.push('Missing schema');
  else {
    if (!Array.isArray(manifest.schema.fields)) {
      errors.push('Invalid schema fields');
    }
  }

  if (!manifest.quality) errors.push('Missing quality metrics');
  if (!manifest.processing) errors.push('Missing processing metadata');

  return {
    valid: errors.length === 0,
    errors
  };
}

/**
 * Generates a human-readable summary of the manifest
 */
export function generateManifestSummary(manifest: TrainingManifest): string {
  const lines: string[] = [];

  lines.push(`Dataset: ${manifest.datasetId}`);
  lines.push(`Created: ${new Date(manifest.created).toLocaleString()}`);
  if (manifest.description) lines.push(`Description: ${manifest.description}`);
  lines.push('');

  lines.push('Statistics:');
  lines.push(`  Total Examples: ${manifest.statistics.totalExamples}`);
  lines.push(`  Tasks: ${manifest.statistics.totalTasks}`);
  lines.push(`  Average Input Length: ${manifest.statistics.averageInputLength}`);
  lines.push(`  Output Coverage: ${(manifest.statistics.outputCoverage * 100).toFixed(1)}%`);
  lines.push('');

  lines.push('Task Distribution:');
  Object.entries(manifest.statistics.taskDistribution)
    .sort((a, b) => b[1] - a[1])
    .forEach(([task, count]) => {
      lines.push(`  ${task}: ${count}`);
    });
  lines.push('');

  lines.push('Quality:');
  lines.push(`  Validation: ${manifest.quality.validationPassed ? 'PASSED' : 'FAILED'}`);
  lines.push(`  Completeness: ${(manifest.quality.completenessScore * 100).toFixed(1)}%`);
  lines.push(`  Errors: ${manifest.quality.errorCount}`);
  lines.push(`  Warnings: ${manifest.quality.warningCount}`);
  lines.push('');

  if (manifest.characteristics.languages) {
    lines.push(`Languages: ${manifest.characteristics.languages.join(', ')}`);
  }

  if (manifest.characteristics.contentTypes) {
    lines.push(`Content Types: ${manifest.characteristics.contentTypes.join(', ')}`);
  }

  return lines.join('\n');
}
