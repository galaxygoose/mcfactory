// This file is generated by the Architect Agent.
// Other agents must implement logic INSIDE this file only.
// Do NOT create or delete files. Respect the MIC + MIM.

import {
  PipelineDefinition,
  PipelineResult,
  PipelineStep,
  FactoryOptions
} from '../../types';
import { TranslationFactory } from '../factories/TranslationFactory';
import { DetectionFactory } from '../factories/DetectionFactory';
import { ModerationFactory } from '../factories/ModerationFactory';
import { AgentFactory } from '../factories/AgentFactory';
import { DataFactory } from '../factories/DataFactory';
import { GuardrailFactory } from '../factories/GuardrailFactory';
import { MediaFactory } from '../factories/MediaFactory';

export class Workflow {
  static async execute(
    pipeline: PipelineDefinition,
    initialData: any,
    options?: FactoryOptions
  ): Promise<PipelineResult<any>> {
    const logs: string[] = [];

    try {
      let currentData = initialData;

      // Execute steps sequentially
      for (const step of pipeline.steps) {
        currentData = await this.executeStep(step, currentData, options, logs);
      }

      return {
        success: true,
        data: currentData,
        logs
      };
    } catch (error) {
      const errorMessage = error instanceof Error ? error.message : 'Unknown workflow error';
      logs.push(`Workflow execution failed: ${errorMessage}`);

      return {
        success: false,
        data: null,
        logs
      };
    }
  }

  private static async executeStep(
    step: PipelineStep,
    data: any,
    options?: FactoryOptions,
    logs: string[] = []
  ): Promise<any> {
    logs.push(`Executing step: ${step.type}`);

    try {
      switch (step.type) {
        case 'translate':
          const translationFactory = new TranslationFactory();
          const translationInput = {
            text: data,
            targetLang: step.options?.targetLang || 'en',
            sourceLang: step.options?.sourceLang,
            preserveFormat: step.options?.preserveFormat
          };
          const translationResult = await translationFactory.run(translationInput, options);
          logs.push(`Translation completed: ${translationResult.translated.substring(0, 50)}...`);
          return translationResult.translated;

        case 'detectAI':
          const detectionFactory = new DetectionFactory();
          const detectionInput = { text: data };
          const detectionResult = await detectionFactory.run(detectionInput, options);
          logs.push(`AI detection completed: ${detectionResult.isAI ? 'AI' : 'Human'} (${detectionResult.confidence})`);
          return { ...data, aiDetection: detectionResult };

        case 'moderate':
          const moderationFactory = new ModerationFactory();
          const moderationInput = { text: data };
          const moderationResult = await moderationFactory.run(moderationInput, options);
          logs.push(`Moderation completed: ${moderationResult.safe ? 'Safe' : 'Flagged'}`);
          return { ...data, moderation: moderationResult };

        case 'summarize':
          const agentFactory = new AgentFactory();
          const summarizationInput = {
            text: data,
            length: step.options?.length || 'medium'
          };
          const summarizationResult = await agentFactory.run(summarizationInput, options);
          logs.push(`Summarization completed: ${summarizationResult.summary.substring(0, 50)}...`);
          return summarizationResult.summary;

        case 'categorize':
          const categorizationInput = {
            text: data,
            tags: step.options?.tags
          };
          const categorizationResult = await agentFactory.run(categorizationInput, options);
          logs.push(`Categorization completed: ${categorizationResult.tags.join(', ')}`);
          return { ...data, categories: categorizationResult.tags };

        case 'sentiment':
          const sentimentInput = { text: data, type: 'sentiment' };
          const sentimentResult = await agentFactory.run(sentimentInput, options);
          logs.push(`Sentiment analysis completed: ${sentimentResult.label} (${sentimentResult.score})`);
          return { ...data, sentiment: sentimentResult };

        case 'data':
          const dataFactory = new DataFactory();
          const dataProcessingInput = {
            text: data,
            operations: step.options?.operations || ['clean']
          };
          const dataProcessingResult = await dataFactory.run(dataProcessingInput, options);
          logs.push(`Data processing completed`);
          return dataProcessingResult.processedText;

        case 'guardrail':
          const guardrailFactory = new GuardrailFactory();
          const guardrailInput = { text: data };
          const guardrailResult = await guardrailFactory.run(guardrailInput, options);
          if (!guardrailResult.safe) {
            throw new Error(`Guardrail check failed: ${guardrailResult.reasons?.join(', ')}`);
          }
          logs.push(`Guardrail check passed`);
          return data;

        case 'stt':
          const mediaFactory = new MediaFactory();
          const sttInput = {
            audioBuffer: data,
            language: step.options?.language
          };
          const sttResult = await mediaFactory.run(sttInput, options);
          logs.push(`Speech-to-text completed: ${sttResult.text.substring(0, 50)}...`);
          return sttResult.text;

        case 'tts':
          const ttsInput = {
            text: data,
            voice: step.options?.voice
          };
          const ttsResult = await mediaFactory.run(ttsInput, options);
          logs.push(`Text-to-speech completed`);
          return ttsResult.audioBuffer;

        case 'ocr':
          const ocrInput = {
            imageBuffer: data,
            type: 'ocr'
          };
          const ocrResult = await mediaFactory.run(ocrInput, options);
          logs.push(`OCR completed: ${ocrResult.text.substring(0, 50)}...`);
          return ocrResult.text;

        case 'caption':
          const captionInput = {
            imageBuffer: data,
            type: 'caption'
          };
          const captionResult = await mediaFactory.run(captionInput, options);
          logs.push(`Image caption completed: ${captionResult.caption}`);
          return captionResult.caption;

        default:
          throw new Error(`Unknown step type: ${step.type}`);
      }
    } catch (error) {
      const errorMessage = error instanceof Error ? error.message : 'Unknown step error';
      logs.push(`Step ${step.type} failed: ${errorMessage}`);
      throw error;
    }
  }
}
