// This file is generated by the Architect Agent.
// Other agents must implement logic INSIDE this file only.
// Do NOT create or delete files. Respect the MIC + MIM.

import { DetectionFactory } from '../../../core/factories/DetectionFactory';
import { AIDetectionInput, AIDetectionOutput } from '../../../types';

const factory = new DetectionFactory();

/**
 * Calculate a basic perplexity estimate based on text complexity
 * Note: This is a simplified approximation. Real perplexity requires language model probabilities.
 */
export function checkPerplexity(text: string): number {
  if (!text || text.length === 0) {
    return 1; // Minimum perplexity
  }

  const words = text.split(/\s+/).filter(w => w.length > 0);
  if (words.length === 0) {
    return 1;
  }

  // Basic perplexity approximation based on:
  // - Vocabulary diversity
  // - Word length variation
  // - Sentence complexity

  const uniqueWords = new Set(words.map(w => w.toLowerCase()));
  const vocabularyRatio = uniqueWords.size / words.length;

  const avgWordLength = words.reduce((sum, word) => sum + word.length, 0) / words.length;
  const wordLengthVariance = words.reduce((sum, word) => sum + Math.pow(word.length - avgWordLength, 2), 0) / words.length;

  // Higher perplexity for more diverse/complex text
  const perplexity = Math.exp(vocabularyRatio * Math.sqrt(wordLengthVariance) * 0.1);

  return Math.max(1, Math.min(1000, perplexity)); // Clamp to reasonable range
}

/**
 * Get perplexity from AI detection analysis (more sophisticated analysis)
 */
export async function analyzePerplexity(text: string): Promise<number> {
  const input: AIDetectionInput = {
    text
  };

  const result: AIDetectionOutput = await factory.run(input);
  return result.features?.perplexity || checkPerplexity(text);
}
