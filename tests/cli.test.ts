// This file is generated by the Architect Agent.
// Other agents must implement logic INSIDE this file only.
// Do NOT create or delete files. Respect the MIC + MIM.

import { initCommand } from '../src/core/cli/commands/init';
import { diagnoseCommand } from '../src/core/cli/commands/diagnose';
import { validateConfigCommand } from '../src/core/cli/commands/validateConfig';
import { runPipelineCommand } from '../src/core/cli/commands/runPipeline';
import { generateManifestCommand } from '../src/core/cli/commands/generateManifest';

// Mock fs module
const mockFs = require('fs');
jest.mock('fs');

// Mock console methods
const mockConsoleLog = jest.spyOn(console, 'log').mockImplementation();
const mockConsoleError = jest.spyOn(console, 'error').mockImplementation();

// Mock process.exit
const mockProcessExit = jest.spyOn(process, 'exit').mockImplementation(() => {
  throw new Error('Process exit called');
});

describe('CLI', () => {
  beforeEach(() => {
    // Reset mocks
    jest.clearAllMocks();
  });

  afterEach(() => {
    // Restore mocks
    mockConsoleLog.mockRestore();
    mockConsoleError.mockRestore();
    mockProcessExit.mockRestore();
  });

  describe('initCommand', () => {
    const configPath = 'mcf.config.json';

    test('should create default config when none exists', () => {
      mockFs.existsSync.mockReturnValue(false);
      mockFs.writeFileSync.mockImplementation();

      initCommand();

      expect(mockFs.existsSync).toHaveBeenCalledWith(configPath);
      expect(mockFs.writeFileSync).toHaveBeenCalledWith(
        configPath,
        expect.stringContaining('"providers": {}')
      );
      expect(mockConsoleLog).toHaveBeenCalledWith(
        expect.stringContaining('Created default MCFACTORY configuration')
      );
    });

    test('should not overwrite existing config', () => {
      mockFs.existsSync.mockReturnValue(true);

      initCommand();

      expect(mockFs.writeFileSync).not.toHaveBeenCalled();
      expect(mockConsoleLog).toHaveBeenCalledWith(
        expect.stringContaining('MCFACTORY configuration already exists')
      );
    });

    test('should handle file write errors', () => {
      mockFs.existsSync.mockReturnValue(false);
      mockFs.writeFileSync.mockImplementation(() => {
        throw new Error('Permission denied');
      });

      initCommand();

      expect(mockConsoleError).toHaveBeenCalledWith(
        'âœ— Failed to initialize MCFACTORY configuration:',
        expect.any(Error)
      );
      expect(mockProcessExit).toHaveBeenCalledWith(1);
    });

    test('should create config with correct structure', () => {
      mockFs.existsSync.mockReturnValue(false);
      let writtenContent = '';
      mockFs.writeFileSync.mockImplementation((path: any, content: any) => {
        writtenContent = content;
      });

      initCommand();

      const config = JSON.parse(writtenContent);
      expect(config).toHaveProperty('providers');
      expect(config).toHaveProperty('defaults');
      expect(config).toHaveProperty('guardrails');
      expect(config.guardrails.enabled).toBe(true);
    });
  });

  describe('validateConfigCommand', () => {
    test('should validate existing config successfully', () => {
      mockFs.existsSync.mockReturnValue(true);
      mockFs.readFileSync.mockReturnValue(JSON.stringify({
        providers: { openai: { apiKey: 'test-key' } },
        defaults: {}
      }));

      validateConfigCommand();

      expect(mockConsoleLog).toHaveBeenCalledWith(
        expect.stringContaining('Configuration is valid')
      );
    });

    test('should report missing config file', () => {
      mockFs.existsSync.mockReturnValue(false);

      validateConfigCommand();

      expect(mockConsoleError).toHaveBeenCalledWith(
        expect.stringContaining('Configuration file not found')
      );
      expect(mockProcessExit).toHaveBeenCalledWith(1);
    });

    test('should report invalid JSON', () => {
      mockFs.existsSync.mockReturnValue(true);
      mockFs.readFileSync.mockReturnValue('invalid json content');

      validateConfigCommand();

      expect(mockConsoleError).toHaveBeenCalledWith(
        expect.stringContaining('Invalid JSON')
      );
      expect(mockProcessExit).toHaveBeenCalledWith(1);
    });

    test('should validate provider configurations', () => {
      const validConfig = {
        providers: {
          openai: { apiKey: 'test-key' },
          anthropic: { apiKey: 'claude-key' }
        },
        defaults: {}
      };

      mockFs.existsSync.mockReturnValue(true);
      mockFs.readFileSync.mockReturnValue(JSON.stringify(validConfig));

      validateConfigCommand();

      expect(mockConsoleLog).toHaveBeenCalledWith(
        expect.stringContaining('âœ“ OpenAI provider configured')
      );
      expect(mockConsoleLog).toHaveBeenCalledWith(
        expect.stringContaining('âœ“ Anthropic provider configured')
      );
    });

    test('should warn about missing API keys', () => {
      const configWithoutKeys = {
        providers: {
          openai: {},
          anthropic: {}
        },
        defaults: {}
      };

      mockFs.existsSync.mockReturnValue(true);
      mockFs.readFileSync.mockReturnValue(JSON.stringify(configWithoutKeys));

      validateConfigCommand();

      expect(mockConsoleLog).toHaveBeenCalledWith(
        expect.stringContaining('âš  OpenAI provider missing apiKey')
      );
    });
  });

  describe('diagnoseCommand', () => {
    test('should run system diagnostics', () => {
      // Mock environment variables
      process.env.OPENAI_API_KEY = 'test-key';
      process.env.NODE_ENV = 'test';

      diagnoseCommand();

      expect(mockConsoleLog).toHaveBeenCalledWith(
        expect.stringContaining('ðŸ” MCFACTORY System Diagnostics')
      );
      expect(mockConsoleLog).toHaveBeenCalledWith(
        expect.stringContaining('Node.js version')
      );
      expect(mockConsoleLog).toHaveBeenCalledWith(
        expect.stringContaining('OpenAI API Key')
      );
    });

    test('should check for missing environment variables', () => {
      // Clear environment variables
      delete process.env.OPENAI_API_KEY;
      delete process.env.ANTHROPIC_API_KEY;

      diagnoseCommand();

      expect(mockConsoleLog).toHaveBeenCalledWith(
        expect.stringContaining('âŒ OpenAI API Key: Not set')
      );
    });

    test('should test provider connectivity', () => {
      process.env.OPENAI_API_KEY = 'test-key';

      // Mock axios for connectivity test
      const mockAxios = require('axios');
      mockAxios.get = jest.fn().mockResolvedValue({ status: 200 });

      diagnoseCommand();

      // Should attempt to test API connectivity
      expect(mockConsoleLog).toHaveBeenCalledWith(
        expect.stringContaining('Testing API connectivity')
      );
    });
  });

  describe('runPipelineCommand', () => {
    test('should run pipeline successfully', () => {
      const pipelineName = 'test-pipeline';

      mockFs.existsSync.mockReturnValue(true);
      mockFs.readFileSync.mockReturnValue(JSON.stringify({
        providers: { openai: { apiKey: 'test' } },
        defaults: {},
        pipelines: {
          [pipelineName]: {
            name: pipelineName,
            steps: [{ type: 'translate' }]
          }
        }
      }));

      runPipelineCommand(pipelineName, {});

      expect(mockConsoleLog).toHaveBeenCalledWith(
        expect.stringContaining(`ðŸš€ Running pipeline: ${pipelineName}`)
      );
    });

    test('should handle missing config file', () => {
      mockFs.existsSync.mockReturnValue(false);

      runPipelineCommand('test-pipeline', {});

      expect(mockConsoleError).toHaveBeenCalledWith(
        expect.stringContaining('Configuration file not found')
      );
      expect(mockProcessExit).toHaveBeenCalledWith(1);
    });

    test('should handle missing pipeline', () => {
      mockFs.existsSync.mockReturnValue(true);
      mockFs.readFileSync.mockReturnValue(JSON.stringify({
        providers: {},
        defaults: {},
        pipelines: {}
      }));

      runPipelineCommand('non-existent-pipeline', {});

      expect(mockConsoleError).toHaveBeenCalledWith(
        expect.stringContaining('Pipeline "non-existent-pipeline" not found')
      );
      expect(mockProcessExit).toHaveBeenCalledWith(1);
    });

    test('should list available pipelines when pipeline not found', () => {
      mockFs.existsSync.mockReturnValue(true);
      mockFs.readFileSync.mockReturnValue(JSON.stringify({
        providers: {},
        defaults: {},
        pipelines: {
          'pipeline1': { name: 'pipeline1', steps: [] },
          'pipeline2': { name: 'pipeline2', steps: [] }
        }
      }));

      runPipelineCommand('missing-pipeline', {});

      expect(mockConsoleLog).toHaveBeenCalledWith(
        expect.stringContaining('Available pipelines: pipeline1, pipeline2')
      );
    });
  });

  describe('generateManifestCommand', () => {
    test('should generate MCP manifest', () => {
      mockFs.existsSync.mockReturnValue(true);
      mockFs.readFileSync.mockReturnValue(JSON.stringify({
        providers: { openai: { apiKey: 'test' } },
        defaults: {}
      }));
      mockFs.writeFileSync.mockImplementation();

      generateManifestCommand();

      expect(mockConsoleLog).toHaveBeenCalledWith(
        expect.stringContaining('Generating MCP manifest')
      );
      expect(mockFs.writeFileSync).toHaveBeenCalledWith(
        'mcp-manifest.json',
        expect.any(String)
      );
    });

    test('should handle missing config', () => {
      mockFs.existsSync.mockReturnValue(false);

      generateManifestCommand();

      expect(mockConsoleError).toHaveBeenCalledWith(
        expect.stringContaining('Configuration file not found')
      );
    });

    test('should create manifest with correct structure', () => {
      mockFs.existsSync.mockReturnValue(true);
      mockFs.readFileSync.mockReturnValue(JSON.stringify({
        providers: { openai: { apiKey: 'test' } },
        defaults: {}
      }));

      let manifestContent = '';
      mockFs.writeFileSync.mockImplementation((path: any, content: any) => {
        if (path === 'mcp-manifest.json') {
          manifestContent = content;
        }
      });

      generateManifestCommand();

      const manifest = JSON.parse(manifestContent);
      expect(manifest).toHaveProperty('mcp');
      expect(manifest).toHaveProperty('tools');
      expect(manifest).toHaveProperty('version');
    });
  });

  describe('CLI Integration', () => {
    test('should handle command line parsing', () => {
      // This test verifies that the CLI structure is correct
      // In a real scenario, we'd test the actual commander.js parsing
      // but for now we verify the command functions exist and are callable
      expect(typeof initCommand).toBe('function');
      expect(typeof diagnoseCommand).toBe('function');
      expect(typeof validateConfigCommand).toBe('function');
      expect(typeof runPipelineCommand).toBe('function');
      expect(typeof generateManifestCommand).toBe('function');
    });

    test('should handle process exit codes correctly', () => {
      // Test that error conditions call process.exit with code 1
      let exitCodes: number[] = [];
      mockProcessExit.mockImplementation((code: any) => {
        exitCodes.push(code || 0);
        throw new Error('Process exit called'); // Prevent actual exit
      });

      // Test missing config scenario
      mockFs.existsSync.mockReturnValue(false);
      try {
        runPipelineCommand('test', {});
      } catch (e) {
        // Expected
      }

      expect(exitCodes).toContain(1);
    });

    test('should provide helpful error messages', () => {
      mockFs.existsSync.mockReturnValue(false);

      try {
        runPipelineCommand('test', {});
      } catch (e) {
        // Expected
      }

      expect(mockConsoleLog).toHaveBeenCalledWith(
        expect.stringContaining('Run "mcfactory init" to create a default configuration')
      );
    });
  });
});
