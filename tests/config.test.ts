// This file is generated by the Architect Agent.
// Other agents must implement logic INSIDE this file only.
// Do NOT create or delete files. Respect the MIC + MIM.

import { ConfigLoader } from '../src/core/config/configLoader';
import { EnvConfig } from '../src/core/config/env';
import { ProviderConfig } from '../src/core/config/providerConfig';
import { MCFACTORYConfig, MCFACTORYEnvironment } from '../src/types';

// Mock fs module
const mockFs = require('fs');
jest.mock('fs');

// Mock path module
const mockPath = require('path');
jest.mock('path');

describe('Config', () => {
  beforeEach(() => {
    // Reset mocks
    jest.clearAllMocks();
  });

  describe('ConfigLoader', () => {
    const mockConfigPath = '/project/mcf.config.json';

    beforeEach(() => {
      mockPath.resolve.mockReturnValue(mockConfigPath);
    });

    test('should load configuration successfully', () => {
      const mockConfig: MCFACTORYConfig = {
        providers: {
          openai: {
            apiKey: 'test-key'
          }
        },
        defaults: {
          translation: {
            targetLang: 'en'
          }
        }
      };

      mockFs.existsSync.mockReturnValue(true);
      mockFs.readFileSync.mockReturnValue(JSON.stringify(mockConfig));

      const result = ConfigLoader.load();

      expect(result).toEqual(mockConfig);
      expect(mockFs.existsSync).toHaveBeenCalledWith(mockConfigPath);
      expect(mockFs.readFileSync).toHaveBeenCalledWith(mockConfigPath, 'utf8');
    });

    test('should throw error when config file does not exist', () => {
      mockFs.existsSync.mockReturnValue(false);

      expect(() => ConfigLoader.load()).toThrow(
        `Configuration file not found: ${mockConfigPath}`
      );
    });

    test('should throw error when config file is invalid JSON', () => {
      mockFs.existsSync.mockReturnValue(true);
      mockFs.readFileSync.mockReturnValue('invalid json content');

      expect(() => ConfigLoader.load()).toThrow('Failed to load configuration');
    });

    test('should handle complex configuration with all sections', () => {
      const complexConfig: MCFACTORYConfig = {
        providers: {
          openai: { apiKey: 'openai-key' },
          anthropic: { apiKey: 'anthropic-key' },
          gemini: { apiKey: 'gemini-key' }
        },
        defaults: {
          translation: { targetLang: 'es', preserveFormat: true },
          detection: { aiThreshold: 0.8 },
          moderation: { allowedCategories: ['safe'] },
          agents: { summaryLength: 'medium' }
        },
        pipelines: {
          'content-pipeline': {
            name: 'content-pipeline',
            steps: [
              { type: 'translate', options: { targetLang: 'fr' } },
              { type: 'detectAI' },
              { type: 'moderate' }
            ]
          }
        },
        training: {
          format: 'jsonl',
          shardSize: 1000,
          schedule: 'weekly'
        },
        guardrails: {
          enabled: true,
          bannedTopics: ['politics', 'religion']
        }
      };

      mockFs.existsSync.mockReturnValue(true);
      mockFs.readFileSync.mockReturnValue(JSON.stringify(complexConfig));

      const result = ConfigLoader.load();

      expect(result).toEqual(complexConfig);
      expect(result.providers).toHaveProperty('openai');
      expect(result.providers).toHaveProperty('anthropic');
      expect(result.pipelines).toHaveProperty('content-pipeline');
      expect(result.training?.format).toBe('jsonl');
      expect(result.guardrails?.enabled).toBe(true);
    });

    test('should handle minimal configuration', () => {
      const minimalConfig: MCFACTORYConfig = {
        providers: {},
        defaults: {}
      };

      mockFs.existsSync.mockReturnValue(true);
      mockFs.readFileSync.mockReturnValue(JSON.stringify(minimalConfig));

      const result = ConfigLoader.load();

      expect(result.providers).toEqual({});
      expect(result.defaults).toEqual({});
      expect(result.pipelines).toBeUndefined();
    });
  });

  describe('EnvConfig', () => {
    test('should return environment variables', () => {
      // Set up test environment variables
      process.env.OPENAI_API_KEY = 'test-openai-key';
      process.env.ANTHROPIC_API_KEY = 'test-anthropic-key';
      process.env.GEMINI_API_KEY = 'test-gemini-key';
      process.env.COHERE_API_KEY = 'test-cohere-key';
      process.env.ELEVENLABS_API_KEY = 'test-elevenlabs-key';
      process.env.LOCAL_MODEL_PATH = '/path/to/model';
      process.env.CUSTOM_VAR = 'custom-value';

      const result = EnvConfig.get();

      expect(result.OPENAI_API_KEY).toBe('test-openai-key');
      expect(result.ANTHROPIC_API_KEY).toBe('test-anthropic-key');
      expect(result.GEMINI_API_KEY).toBe('test-gemini-key');
      expect(result.COHERE_API_KEY).toBe('test-cohere-key');
      expect(result.ELEVENLABS_API_KEY).toBe('test-elevenlabs-key');
      expect(result.LOCAL_MODEL_PATH).toBe('/path/to/model');
    });

    test('should handle missing environment variables', () => {
      // Clear all environment variables
      delete process.env.OPENAI_API_KEY;
      delete process.env.ANTHROPIC_API_KEY;
      delete process.env.GEMINI_API_KEY;
      delete process.env.COHERE_API_KEY;
      delete process.env.ELEVENLABS_API_KEY;
      delete process.env.LOCAL_MODEL_PATH;

      const result = EnvConfig.get();

      expect(result.OPENAI_API_KEY).toBeUndefined();
      expect(result.ANTHROPIC_API_KEY).toBeUndefined();
      expect(result.GEMINI_API_KEY).toBeUndefined();
      expect(result.COHERE_API_KEY).toBeUndefined();
      expect(result.ELEVENLABS_API_KEY).toBeUndefined();
      expect(result.LOCAL_MODEL_PATH).toBeUndefined();
    });

    test('should return MCFACTORYEnvironment typed object', () => {
      process.env.OPENAI_API_KEY = 'test-key';

      const result = EnvConfig.get() as MCFACTORYEnvironment;

      expect(result.OPENAI_API_KEY).toBe('test-key');
      expect(typeof result).toBe('object');
    });
  });

  describe('ProviderConfig', () => {
    test('should return provider configuration', () => {
      const result = ProviderConfig.get();

      // Since ProviderConfig.get() returns an empty object currently,
      // we just test that it returns an object
      expect(typeof result).toBe('object');
    });

    test('should be extensible for future provider configuration', () => {
      const result = ProviderConfig.get();

      // Test that the result can be extended (simulating future config)
      expect(() => {
        Object.assign(result, { customProvider: { apiKey: 'custom-key' } });
      }).not.toThrow();
    });
  });

  describe('Configuration Integration', () => {
    test('should validate configuration structure', () => {
      const validConfig: MCFACTORYConfig = {
        providers: {
          openai: { apiKey: 'test-key', model: 'gpt-4' },
          anthropic: { apiKey: 'claude-key' }
        },
        defaults: {
          translation: { targetLang: 'en' },
          detection: { aiThreshold: 0.8, fakeVoiceThreshold: 0.7 },
          moderation: { allowedCategories: ['safe', 'discuss'] },
          agents: { summaryLength: 'medium' },
          media: { maxDurationMs: 300000 },
          training: { format: 'jsonl', shardSize: 1000, schedule: 'daily' }
        }
      };

      mockFs.existsSync.mockReturnValue(true);
      mockFs.readFileSync.mockReturnValue(JSON.stringify(validConfig));

      const result = ConfigLoader.load();

      // Test that all expected properties are present
      expect(result.providers).toHaveProperty('openai');
      expect(result.providers).toHaveProperty('anthropic');
      expect(result.defaults.translation?.targetLang).toBe('en');
      expect(result.defaults.detection?.aiThreshold).toBe(0.8);
      expect(result.defaults.moderation?.allowedCategories).toEqual(['safe', 'discuss']);
      expect(result.defaults.agents?.summaryLength).toBe('medium');
      expect(result.defaults.media?.maxDurationMs).toBe(300000);
      expect(result.defaults.training?.format).toBe('jsonl');
      expect(result.defaults.training?.shardSize).toBe(1000);
      expect(result.defaults.training?.schedule).toBe('daily');
    });

    test('should handle configuration with local provider', () => {
      const configWithLocal: MCFACTORYConfig = {
        providers: {
          local: {
            modelPath: '/models/llama-7b',
            tokenizerPath: '/models/tokenizer'
          }
        },
        defaults: {}
      };

      mockFs.existsSync.mockReturnValue(true);
      mockFs.readFileSync.mockReturnValue(JSON.stringify(configWithLocal));

      const result = ConfigLoader.load();

      expect(result.providers.local?.modelPath).toBe('/models/llama-7b');
      expect(result.providers.local?.tokenizerPath).toBe('/models/tokenizer');
    });

    test('should handle configuration with pipeline definitions', () => {
      const configWithPipelines: MCFACTORYConfig = {
        providers: { openai: { apiKey: 'test' } },
        defaults: {},
        pipelines: {
          'text-processing': {
            name: 'text-processing',
            steps: [
              { type: 'translate', options: { targetLang: 'es' } },
              { type: 'moderate' },
              { type: 'summarize', options: { length: 'short' } }
            ]
          },
          'content-analysis': {
            name: 'content-analysis',
            steps: [
              { type: 'detectAI' },
              { type: 'analyzeSentiment' },
              { type: 'categorize' }
            ]
          }
        }
      };

      mockFs.existsSync.mockReturnValue(true);
      mockFs.readFileSync.mockReturnValue(JSON.stringify(configWithPipelines));

      const result = ConfigLoader.load();

      expect(result.pipelines).toHaveProperty('text-processing');
      expect(result.pipelines).toHaveProperty('content-analysis');
      expect(result.pipelines!['text-processing'].steps).toHaveLength(3);
      expect(result.pipelines!['content-analysis'].steps).toHaveLength(3);
    });

    test('should handle configuration with guardrails', () => {
      const configWithGuardrails: MCFACTORYConfig = {
        providers: { openai: { apiKey: 'test' } },
        defaults: {},
        guardrails: {
          enabled: true,
          bannedTopics: ['violence', 'hate', 'explicit'],
          hallucinationThreshold: 0.8
        }
      };

      mockFs.existsSync.mockReturnValue(true);
      mockFs.readFileSync.mockReturnValue(JSON.stringify(configWithGuardrails));

      const result = ConfigLoader.load();

      expect(result.guardrails?.enabled).toBe(true);
      expect(result.guardrails?.bannedTopics).toEqual(['violence', 'hate', 'explicit']);
      expect(result.guardrails?.hallucinationThreshold).toBe(0.8);
    });

    test('should handle configuration with training settings', () => {
      const configWithTraining: MCFACTORYConfig = {
        providers: { openai: { apiKey: 'test' } },
        defaults: {},
        training: {
          format: 'parquet',
          shardSize: 5000,
          schedule: 'monthly',
          outputDir: '/training/data'
        }
      };

      mockFs.existsSync.mockReturnValue(true);
      mockFs.readFileSync.mockReturnValue(JSON.stringify(configWithTraining));

      const result = ConfigLoader.load();

      expect(result.training?.format).toBe('parquet');
      expect(result.training?.shardSize).toBe(5000);
      expect(result.training?.schedule).toBe('monthly');
      expect(result.training?.outputDir).toBe('/training/data');
    });
  });
});
