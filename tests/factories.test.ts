// This file is generated by the Architect Agent.
// Other agents must implement logic INSIDE this file only.
// Do NOT create or delete files. Respect the MIC + MIM.

import { TranslationFactory } from '../src/core/factories/TranslationFactory';
import { ModerationFactory } from '../src/core/factories/ModerationFactory';
import { DetectionFactory } from '../src/core/factories/DetectionFactory';
import { AgentFactory } from '../src/core/factories/AgentFactory';
import { MediaFactory } from '../src/core/factories/MediaFactory';
import { TrainingFactory } from '../src/core/factories/TrainingFactory';
import { GuardrailFactory } from '../src/core/factories/GuardrailFactory';
import { WorkflowFactory } from '../src/core/factories/WorkflowFactory';
import { ProviderRegistry } from '../src/core/providers/providerRegistry';
import {
  TranslationInput,
  ModerationInput,
  AIDetectionInput,
  FakeVoiceDetectionInput,
  SummarizationInput,
  SentimentInput,
  CategorizationInput,
  STTInput,
  TTSInput,
  OCRInput,
  ImageCaptionInput,
  TrainingExportConfig,
  GuardrailConfig
} from '../src/types';

describe('Factories', () => {
  let mockProvider: any;

  beforeEach(() => {
    // Reset provider registry
    (ProviderRegistry as any).providers.clear();

    // Create and register mock providers
    mockProvider = global.testUtils.createMockProvider('openai');
    const whisperProvider = global.testUtils.createMockProvider('whisper');
    const elevenLabsProvider = global.testUtils.createMockProvider('elevenlabs');

    ProviderRegistry.registerProvider(mockProvider);
    ProviderRegistry.registerProvider(whisperProvider);
    ProviderRegistry.registerProvider(elevenLabsProvider);

    // Reset mocks
    global.testUtils.resetMocks();
  });

  describe('TranslationFactory', () => {
    let factory: TranslationFactory;

    beforeEach(() => {
      factory = new TranslationFactory();
    });

    test('should translate text successfully', async () => {
      const input: TranslationInput = {
        text: 'Hello world',
        targetLang: 'es'
      };

      const mockResponse = global.testUtils.createMockProviderResponse(
        'Hola mundo',
        150,
        'gpt-4',
        'openai'
      );

      mockProvider.callModel.mockResolvedValue(mockResponse);

      const result = await factory.run(input);

      expect(result.translated).toBe('Hola mundo');
      expect(result.targetLang).toBe('es');
      expect(result.provider).toBe('openai');
      expect(result.tokens).toBe(150);
      expect(mockProvider.callModel).toHaveBeenCalledTimes(1);
    });

    test('should handle source language specification', async () => {
      const input: TranslationInput = {
        text: 'Hello world',
        sourceLang: 'en',
        targetLang: 'fr'
      };

      const mockResponse = global.testUtils.createMockProviderResponse('Bonjour le monde');
      mockProvider.callModel.mockResolvedValue(mockResponse);

      await factory.run(input);

      const callArgs = mockProvider.callModel.mock.calls[0][0];
      expect(callArgs.input).toContain('from en');
    });

    test('should handle preserveFormat option', async () => {
      const input: TranslationInput = {
        text: 'Hello\nworld',
        targetLang: 'de',
        preserveFormat: true
      };

      const mockResponse = global.testUtils.createMockProviderResponse('Hallo\nWelt');
      mockProvider.callModel.mockResolvedValue(mockResponse);

      await factory.run(input);

      const callArgs = mockProvider.callModel.mock.calls[0][0];
      expect(callArgs.input).toContain('Preserve the original formatting');
    });

    test('should throw error when provider not found', async () => {
      const input: TranslationInput = {
        text: 'Hello world',
        targetLang: 'es'
      };

      // Clear providers
      (ProviderRegistry as any).providers.clear();

      await expect(factory.run(input)).rejects.toThrow('Provider openai not found');
    });

    test('should use custom provider when specified', async () => {
      const customProvider = global.testUtils.createMockProvider('anthropic');
      ProviderRegistry.registerProvider(customProvider);

      const input: TranslationInput = {
        text: 'Hello world',
        targetLang: 'es'
      };

      const mockResponse = global.testUtils.createMockProviderResponse('Hola mundo');
      customProvider.callModel.mockResolvedValue(mockResponse);

      await factory.run(input, { provider: 'anthropic' });

      expect(customProvider.callModel).toHaveBeenCalledTimes(1);
    });

    test('should handle debug mode', async () => {
      const input: TranslationInput = {
        text: 'Hello world',
        targetLang: 'es'
      };

      const mockResponse = global.testUtils.createMockProviderResponse('Hola mundo');
      mockProvider.callModel.mockResolvedValue(mockResponse);

      const consoleSpy = jest.spyOn(console, 'log').mockImplementation();

      await factory.run(input, { debug: true });

      expect(consoleSpy).toHaveBeenCalledWith('Translation request:', expect.any(Object));
      expect(consoleSpy).toHaveBeenCalledWith('Translation response:', mockResponse);

      consoleSpy.mockRestore();
    });
  });

  describe('ModerationFactory', () => {
    let factory: ModerationFactory;

    beforeEach(() => {
      factory = new ModerationFactory();
    });

    test('should moderate safe content', async () => {
      const input: ModerationInput = {
        text: 'This is a normal message'
      };

      const mockResponse = global.testUtils.createMockProviderResponse(JSON.stringify({
        safe: true,
        categories: [],
        confidence: 0.95,
        flagged: false
      }));

      mockProvider.callModel.mockResolvedValue(mockResponse);

      const result = await factory.run(input);

      expect(result.safe).toBe(true);
      expect(result.categories).toEqual([]);
      expect(result.confidence).toBe(0.95);
      expect(result.flagged).toBe(false);
    });

    test('should detect harmful content', async () => {
      const input: ModerationInput = {
        text: 'This contains hate speech'
      };

      const mockResponse = global.testUtils.createMockProviderResponse(JSON.stringify({
        safe: false,
        categories: ['hate_speech', 'harassment'],
        confidence: 0.87,
        flagged: true
      }));

      mockProvider.callModel.mockResolvedValue(mockResponse);

      const result = await factory.run(input);

      expect(result.safe).toBe(false);
      expect(result.categories).toEqual(['hate_speech', 'harassment']);
      expect(result.flagged).toBe(true);
    });

    test('should handle non-JSON responses with fallback parsing', async () => {
      const input: ModerationInput = {
        text: 'This is inappropriate content with hate and violence'
      };

      const mockResponse = global.testUtils.createMockProviderResponse(
        'This content appears to contain hate speech and violent themes. It should be flagged.'
      );

      mockProvider.callModel.mockResolvedValue(mockResponse);

      const result = await factory.run(input);

      expect(result.safe).toBe(false);
      expect(result.flagged).toBe(true);
    });

    test('should handle malformed JSON gracefully', async () => {
      const input: ModerationInput = {
        text: 'Test content'
      };

      const mockResponse = global.testUtils.createMockProviderResponse('{invalid json}');
      mockProvider.callModel.mockResolvedValue(mockResponse);

      const result = await factory.run(input);

      expect(result.safe).toBe(true); // Fallback to safe
      expect(result.categories).toEqual([]);
    });
  });

  describe('DetectionFactory', () => {
    let factory: DetectionFactory;

    beforeEach(() => {
      factory = new DetectionFactory();
    });

    describe('AI Detection', () => {
      test('should detect AI-generated text', async () => {
        const input: AIDetectionInput = {
          text: 'This is clearly AI-generated content with perfect grammar.'
        };

        const mockResponse = global.testUtils.createMockProviderResponse(JSON.stringify({
          isAI: true,
          confidence: 0.92,
          features: {
            entropy: 0.85,
            perplexity: 45.2,
            stylometry: { 'sentence_length': 0.78 }
          }
        }));

        mockProvider.callModel.mockResolvedValue(mockResponse);

        const result = await factory.run(input);

        expect(result.isAI).toBe(true);
        expect(result.confidence).toBe(0.92);
        expect(result.features).toHaveProperty('entropy');
      });

      test('should detect human-written text', async () => {
        const input: AIDetectionInput = {
          text: 'Hey whats up? This is totally human written lol'
        };

        const mockResponse = global.testUtils.createMockProviderResponse(JSON.stringify({
          isAI: false,
          confidence: 0.15,
          features: {}
        }));

        mockProvider.callModel.mockResolvedValue(mockResponse);

        const result = await factory.run(input);

        expect(result.isAI).toBe(false);
        expect(result.confidence).toBe(0.15);
      });

      test('should handle non-JSON AI detection responses', async () => {
        const input: AIDetectionInput = {
          text: 'This appears to be generated by AI'
        };

        const mockResponse = global.testUtils.createMockProviderResponse(
          'This text shows clear signs of AI generation with unnatural patterns.'
        );

        mockProvider.callModel.mockResolvedValue(mockResponse);

        const result = await factory.run(input);

        expect(result.isAI).toBe(true);
        expect(result.confidence).toBe(0.8);
      });
    });

    describe('Fake Voice Detection', () => {
      test('should detect fake voice', async () => {
        const input: FakeVoiceDetectionInput = {
          audioBuffer: new ArrayBuffer(1024)
        };

        const mockResponse = global.testUtils.createMockProviderResponse(JSON.stringify({
          isFake: true,
          confidence: 0.89,
          details: { 'spectral_artifacts': 'detected' }
        }));

        mockProvider.callModel.mockResolvedValue(mockResponse);

        const result = await factory.run(input);

        expect(result.isFake).toBe(true);
        expect(result.confidence).toBe(0.89);
        expect(result.details).toHaveProperty('spectral_artifacts');
      });

      test('should detect real voice', async () => {
        const input: FakeVoiceDetectionInput = {
          audioBuffer: new ArrayBuffer(2048)
        };

        const mockResponse = global.testUtils.createMockProviderResponse(JSON.stringify({
          isFake: false,
          confidence: 0.12,
          details: {}
        }));

        mockProvider.callModel.mockResolvedValue(mockResponse);

        const result = await factory.run(input);

        expect(result.isFake).toBe(false);
        expect(result.confidence).toBe(0.12);
      });
    });

    test('should throw error for invalid input type', async () => {
      const invalidInput = { invalid: 'input' } as any;

      await expect(factory.run(invalidInput)).rejects.toThrow('Invalid detection input type');
    });
  });

  describe('AgentFactory', () => {
    let factory: AgentFactory;

    beforeEach(() => {
      factory = new AgentFactory();
    });

    test('should summarize text', async () => {
      const input: SummarizationInput = {
        text: 'This is a long article about artificial intelligence and machine learning...',
        length: 'short'
      };

      const mockResponse = global.testUtils.createMockProviderResponse(
        'AI and ML are transforming technology.'
      );

      mockProvider.callModel.mockResolvedValue(mockResponse);

      const result = await factory.run(input);

      expect(result.summary).toContain('AI');
      expect(result.length).toBe('short');
    });

    test('should analyze sentiment', async () => {
      const input: SentimentInput = {
        text: 'I love this product! It works perfectly.',
        type: 'sentiment'
      };

      const mockResponse = global.testUtils.createMockProviderResponse(JSON.stringify({
        label: 'positive',
        score: 0.95
      }));

      mockProvider.callModel.mockResolvedValue(mockResponse);

      const result = await factory.run(input);

      expect(result.label).toBe('positive');
      expect(result.score).toBe(0.95);
    });

    test('should categorize text', async () => {
      const input: CategorizationInput = {
        text: 'Python programming tutorial for beginners',
        tags: ['tutorial', 'programming'],
        type: 'categorization'
      };

      const mockResponse = global.testUtils.createMockProviderResponse(JSON.stringify({
        tags: ['tutorial', 'programming', 'python', 'education'],
        category: 'educational'
      }));

      mockProvider.callModel.mockResolvedValue(mockResponse);

      const result = await factory.run(input);

      expect(result.tags).toContain('tutorial');
      expect(result.tags).toContain('programming');
      expect(result.category).toBe('educational');
    });
  });

  describe('MediaFactory', () => {
    let factory: MediaFactory;

    beforeEach(() => {
      factory = new MediaFactory();
    });

    test('should convert speech to text', async () => {
      const input: STTInput = {
        audioBuffer: new ArrayBuffer(1024),
        language: 'en'
      };

      const mockResponse = global.testUtils.createMockProviderResponse({
        text: 'Hello, this is a test transcription.',
        language: 'en'
      });

      mockProvider.callModel.mockResolvedValue(mockResponse);

      const result = await factory.run(input);

      expect(result.text).toContain('Hello');
      expect(result.language).toBe('en');
    });

    test('should convert text to speech', async () => {
      const input: TTSInput = {
        text: 'Hello world',
        voice: 'female'
      };

      const audioBuffer = new ArrayBuffer(4096);
      const mockResponse = global.testUtils.createMockProviderResponse(audioBuffer);

      mockProvider.callModel.mockResolvedValue(mockResponse);

      const result = await factory.run(input);

      expect(result.audioBuffer).toBeInstanceOf(ArrayBuffer);
      expect(result.audioBuffer.byteLength).toBe(4096);
    });

    test('should extract text from image', async () => {
      const input: OCRInput = {
        imageBuffer: new ArrayBuffer(2048),
        type: 'ocr'
      };

      const mockResponse = global.testUtils.createMockProviderResponse(JSON.stringify({
        text: 'Extracted text from image',
        blocks: [{ bbox: [10, 10, 100, 20], text: 'Extracted text from image' }]
      }));

      mockProvider.callModel.mockResolvedValue(mockResponse);

      const result = await factory.run(input);

      expect(result.text).toContain('Extracted');
      expect(result.blocks).toBeDefined();
    });

    test('should caption image', async () => {
      const input: ImageCaptionInput = {
        imageBuffer: new ArrayBuffer(3072),
        type: 'caption'
      };

      const mockResponse = global.testUtils.createMockProviderResponse(JSON.stringify({
        caption: 'A beautiful sunset over mountains',
        confidence: 0.92
      }));

      mockProvider.callModel.mockResolvedValue(mockResponse);

      const result = await factory.run(input);

      expect(result.caption).toContain('sunset');
      expect(result.confidence).toBe(0.92);
    });
  });

});
