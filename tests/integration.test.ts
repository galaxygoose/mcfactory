// This file is generated by the Architect Agent.
// Other agents must implement logic INSIDE this file only.
// Do NOT create or delete files. Respect the MIC + MIM.

import { TranslationFactory } from '../src/core/factories/TranslationFactory';
import { ModerationFactory } from '../src/core/factories/ModerationFactory';
import { AgentFactory } from '../src/core/factories/AgentFactory';
import { DetectionFactory } from '../src/core/factories/DetectionFactory';
import { ProviderRegistry } from '../src/core/providers/providerRegistry';
import {
  TranslationInput,
  ModerationInput,
  AIDetectionInput,
  SummarizationInput,
  SentimentInput
} from '../src/types';

describe('Integration Tests', () => {
  let mockProvider: any;

  beforeEach(() => {
    // Reset provider registry
    (ProviderRegistry as any).providers.clear();

    // Create mock provider
    mockProvider = global.testUtils.createMockProvider('openai');
    ProviderRegistry.registerProvider(mockProvider);

    // Reset mocks
    global.testUtils.resetMocks();
  });

  describe('Content Processing Pipeline', () => {
    test('should run complete content processing pipeline: translate → moderate → analyze sentiment → summarize', async () => {
      const translationFactory = new TranslationFactory();
      const moderationFactory = new ModerationFactory();
      const agentFactory = new AgentFactory();

      // Mock all provider responses
      mockProvider.callModel
        .mockResolvedValueOnce(global.testUtils.createMockProviderResponse(
          'Hola mundo, ¿cómo estás?'
        ))
        .mockResolvedValueOnce(global.testUtils.createMockProviderResponse(JSON.stringify({
          safe: true,
          categories: [],
          confidence: 0.95,
          flagged: false
        })))
        .mockResolvedValueOnce(global.testUtils.createMockProviderResponse(JSON.stringify({
          label: 'positive',
          score: 0.85
        })))
        .mockResolvedValueOnce(global.testUtils.createMockProviderResponse(
          'A friendly Spanish greeting asking how someone is doing.'
        ));

      // Step 1: Translation
      const translationInput: TranslationInput = {
        text: 'Hello world, how are you?',
        targetLang: 'es'
      };
      const translationResult = await translationFactory.run(translationInput);

      expect(translationResult.translated).toBe('Hola mundo, ¿cómo estás?');
      expect(translationResult.targetLang).toBe('es');

      // Step 2: Moderation
      const moderationInput: ModerationInput = {
        text: translationResult.translated
      };
      const moderationResult = await moderationFactory.run(moderationInput);

      expect(moderationResult.safe).toBe(true);
      expect(moderationResult.flagged).toBe(false);

      // Step 3: Sentiment Analysis (only if content is safe)
      if (moderationResult.safe) {
        const sentimentInput: SentimentInput = {
          text: translationResult.translated,
          type: 'sentiment'
        };
        const sentimentResult = await agentFactory.run(sentimentInput);

        expect(sentimentResult.label).toBe('positive');
        expect(sentimentResult.score).toBe(0.85);
      }

      // Step 4: Summarization
      const summaryInput: SummarizationInput = {
        text: translationResult.translated,
        length: 'short'
      };
      const summaryResult = await agentFactory.run(summaryInput);

      expect(summaryResult.summary).toContain('Spanish greeting');
      expect(summaryResult.length).toBe('short');

      // Verify total API calls
      expect(mockProvider.callModel).toHaveBeenCalledTimes(4);
    });

    test('should handle unsafe content in pipeline and skip downstream processing', async () => {
      const translationFactory = new TranslationFactory();
      const moderationFactory = new ModerationFactory();

      // Mock translation success but moderation failure
      mockProvider.callModel
        .mockResolvedValueOnce(global.testUtils.createMockProviderResponse(
          'Contenido inapropiado en español'
        ))
        .mockResolvedValueOnce(global.testUtils.createMockProviderResponse(JSON.stringify({
          safe: false,
          categories: ['hate_speech'],
          confidence: 0.92,
          flagged: true
        })));

      // Step 1: Translation
      const translationInput: TranslationInput = {
        text: 'Some inappropriate content',
        targetLang: 'es'
      };
      const translationResult = await translationFactory.run(translationInput);

      // Step 2: Moderation (fails)
      const moderationInput: ModerationInput = {
        text: translationResult.translated
      };
      const moderationResult = await moderationFactory.run(moderationInput);

      expect(moderationResult.safe).toBe(false);
      expect(moderationResult.categories).toContain('hate_speech');
      expect(moderationResult.flagged).toBe(true);

      // Verify that pipeline stops here - no further processing should occur
      expect(mockProvider.callModel).toHaveBeenCalledTimes(2);
    });

    test('should handle AI detection in content analysis pipeline', async () => {
      const detectionFactory = new DetectionFactory();
      const agentFactory = new AgentFactory();

      // Mock AI detection and categorization
      mockProvider.callModel
        .mockResolvedValueOnce(global.testUtils.createMockProviderResponse(JSON.stringify({
          isAI: false,
          confidence: 0.15,
          features: {
            entropy: 0.72,
            perplexity: 125.3
          }
        })))
        .mockResolvedValueOnce(global.testUtils.createMockProviderResponse(JSON.stringify({
          tags: ['greeting', 'casual', 'human-written'],
          category: 'social'
        })));

      // Step 1: AI Detection
      const aiDetectionInput: AIDetectionInput = {
        text: 'Hey there! Just wanted to say hi and see how you\'re doing today.'
      };
      const aiDetectionResult = await detectionFactory.run(aiDetectionInput);

      expect(aiDetectionResult.isAI).toBe(false);
      expect(aiDetectionResult.confidence).toBe(0.15);
      expect(aiDetectionResult.features).toHaveProperty('entropy');

      // Step 2: Categorization (based on AI detection result)
      if (!aiDetectionResult.isAI) {
        const categorizationResult = await agentFactory.run({
          text: aiDetectionInput.text,
          type: 'categorization'
        });

        expect(categorizationResult.tags).toContain('greeting');
        expect(categorizationResult.tags).toContain('casual');
        expect(categorizationResult.category).toBe('social');
      }

      expect(mockProvider.callModel).toHaveBeenCalledTimes(2);
    });
  });

  describe('Multilingual Content Pipeline', () => {
    test('should process content through multiple language transformations', async () => {
      const translationFactory = new TranslationFactory();
      const agentFactory = new AgentFactory();

      // Chain: English → French → German → back to English
      const languages = ['fr', 'de', 'en'];
      let currentText = 'The weather is beautiful today!';
      const results: string[] = [currentText];

      for (const targetLang of languages) {
        mockProvider.callModel.mockResolvedValueOnce(
          global.testUtils.createMockProviderResponse(
            targetLang === 'fr' ? 'Le temps est beau aujourd\'hui!' :
            targetLang === 'de' ? 'Das Wetter ist heute schön!' :
            'The weather is beautiful today!'
          )
        );

        const translationResult = await translationFactory.run({
          text: currentText,
          targetLang
        });

        currentText = translationResult.translated;
        results.push(currentText);
      }

      // Add summarization step
      mockProvider.callModel.mockResolvedValueOnce(
        global.testUtils.createMockProviderResponse(
          'Weather observation translated across multiple languages.'
        )
      );

      const summaryResult = await agentFactory.run({
        text: results.join(' | '),
        length: 'medium'
      });

      expect(results).toHaveLength(4); // Original + 3 translations
      expect(results[0]).toBe('The weather is beautiful today!');
      expect(results[1]).toContain('beau'); // French
      expect(results[2]).toContain('Wetter'); // German
      expect(results[3]).toBe('The weather is beautiful today!'); // Back to English

      expect(summaryResult.summary).toContain('Weather');
      expect(summaryResult.length).toBe('medium');

      expect(mockProvider.callModel).toHaveBeenCalledTimes(4);
    });
  });

  describe('Error Handling and Recovery', () => {
    test('should handle provider failures gracefully in pipeline', async () => {
      const translationFactory = new TranslationFactory();
      const moderationFactory = new ModerationFactory();

      // Mock translation success but moderation API failure
      mockProvider.callModel
        .mockResolvedValueOnce(global.testUtils.createMockProviderResponse('Hola mundo'))
        .mockRejectedValueOnce(new Error('API rate limit exceeded'));

      // Step 1: Translation succeeds
      const translationResult = await translationFactory.run({
        text: 'Hello world',
        targetLang: 'es'
      });
      expect(translationResult.translated).toBe('Hola mundo');

      // Step 2: Moderation fails - should handle error gracefully
      const moderationInput: ModerationInput = {
        text: translationResult.translated
      };

      await expect(moderationFactory.run(moderationInput))
        .rejects.toThrow('API rate limit exceeded');

      // Pipeline should be able to continue with partial results
      expect(translationResult.translated).toBeDefined();
    });

    test('should handle malformed responses in pipeline steps', async () => {
      const moderationFactory = new ModerationFactory();

      // Mock malformed JSON response
      mockProvider.callModel.mockResolvedValueOnce(
        global.testUtils.createMockProviderResponse('{invalid json response}')
      );

      const moderationInput: ModerationInput = {
        text: 'Test content for moderation'
      };

      const result = await moderationFactory.run(moderationInput);

      // Should fallback to safe defaults
      expect(result.safe).toBe(true);
      expect(result.categories).toEqual([]);
      expect(result.confidence).toBeDefined();
    });
  });

  describe('Performance and Scaling', () => {
    test('should handle multiple concurrent pipeline executions', async () => {
      const translationFactory = new TranslationFactory();
      const promises: Promise<any>[] = [];

      // Create 5 concurrent translation requests
      for (let i = 0; i < 5; i++) {
        mockProvider.callModel.mockResolvedValueOnce(
          global.testUtils.createMockProviderResponse(`Translated text ${i}`)
        );

        promises.push(translationFactory.run({
          text: `Input text ${i}`,
          targetLang: 'es'
        }));
      }

      const results = await Promise.all(promises);

      expect(results).toHaveLength(5);
      results.forEach((result, index) => {
        expect(result.translated).toBe(`Translated text ${index}`);
        expect(result.provider).toBe('openai');
      });

      expect(mockProvider.callModel).toHaveBeenCalledTimes(5);
    });

    test('should maintain pipeline state across steps', async () => {
      const translationFactory = new TranslationFactory();
      const moderationFactory = new ModerationFactory();
      const agentFactory = new AgentFactory();

      // Pipeline state
      const pipelineState = {
        originalText: '',
        translatedText: '',
        isSafe: false,
        sentiment: '',
        summary: ''
      };

      // Step 1: Translation
      mockProvider.callModel.mockResolvedValueOnce(
        global.testUtils.createMockProviderResponse('Bonjour le monde')
      );

      const translationResult = await translationFactory.run({
        text: 'Hello world',
        targetLang: 'fr'
      });

      pipelineState.originalText = 'Hello world';
      pipelineState.translatedText = translationResult.translated;

      // Step 2: Moderation
      mockProvider.callModel.mockResolvedValueOnce(
        global.testUtils.createMockProviderResponse(JSON.stringify({
          safe: true,
          categories: [],
          confidence: 0.88,
          flagged: false
        }))
      );

      const moderationResult = await moderationFactory.run({
        text: pipelineState.translatedText
      });

      pipelineState.isSafe = moderationResult.safe;

      // Step 3: Sentiment (only if safe)
      if (pipelineState.isSafe) {
        mockProvider.callModel.mockResolvedValueOnce(
          global.testUtils.createMockProviderResponse(JSON.stringify({
            label: 'neutral',
            score: 0.6
          }))
        );

        const sentimentResult = await agentFactory.run({
          text: pipelineState.translatedText,
          type: 'sentiment'
        });

        pipelineState.sentiment = sentimentResult.label;

        // Step 4: Summary
        mockProvider.callModel.mockResolvedValueOnce(
          global.testUtils.createMockProviderResponse('A simple greeting in French.')
        );

        const summaryResult = await agentFactory.run({
          text: pipelineState.translatedText,
          length: 'short'
        });

        pipelineState.summary = summaryResult.summary;
      }

      // Verify final state
      expect(pipelineState.originalText).toBe('Hello world');
      expect(pipelineState.translatedText).toBe('Bonjour le monde');
      expect(pipelineState.isSafe).toBe(true);
      expect(pipelineState.sentiment).toBe('neutral');
      expect(pipelineState.summary).toContain('French');

      expect(mockProvider.callModel).toHaveBeenCalledTimes(4);
    });
  });

  describe('Cross-Service Integration', () => {
    test('should integrate multiple factory types in complex workflow', async () => {
      const translationFactory = new TranslationFactory();
      const detectionFactory = new DetectionFactory();
      const agentFactory = new AgentFactory();

      const workflow = {
        input: 'I absolutely love this amazing product! It works perfectly.',
        steps: [] as string[],
        results: {} as any
      };

      // Step 1: Detect if AI-generated
      mockProvider.callModel.mockResolvedValueOnce(
        global.testUtils.createMockProviderResponse(JSON.stringify({
          isAI: false,
          confidence: 0.12,
          features: { entropy: 0.75 }
        }))
      );

      const aiResult = await detectionFactory.run({ text: workflow.input });
      workflow.steps.push('ai-detection');
      workflow.results.aiDetection = aiResult;

      // Step 2: Analyze sentiment
      mockProvider.callModel.mockResolvedValueOnce(
        global.testUtils.createMockProviderResponse(JSON.stringify({
          label: 'positive',
          score: 0.92
        }))
      );

      const sentimentResult = await agentFactory.run({
        text: workflow.input,
        type: 'sentiment'
      });
      workflow.steps.push('sentiment-analysis');
      workflow.results.sentiment = sentimentResult;

      // Step 3: Translate if positive sentiment
      if (sentimentResult.label === 'positive') {
        mockProvider.callModel.mockResolvedValueOnce(
          global.testUtils.createMockProviderResponse('¡Me encanta absolutamente este producto increíble! ¡Funciona perfectamente!')
        );

        const translationResult = await translationFactory.run({
          text: workflow.input,
          targetLang: 'es'
        });
        workflow.steps.push('translation');
        workflow.results.translation = translationResult;

        // Step 4: Summarize the translated text
        mockProvider.callModel.mockResolvedValueOnce(
          global.testUtils.createMockProviderResponse('Reseña positiva entusiasta de un producto que funciona perfectamente.')
        );

        const summaryResult = await agentFactory.run({
          text: translationResult.translated,
          length: 'medium'
        });
        workflow.steps.push('summarization');
        workflow.results.summary = summaryResult;
      }

      // Verify complete workflow
      expect(workflow.steps).toEqual(['ai-detection', 'sentiment-analysis', 'translation', 'summarization']);
      expect(workflow.results.aiDetection.isAI).toBe(false);
      expect(workflow.results.sentiment.label).toBe('positive');
      expect(workflow.results.translation.targetLang).toBe('es');
      expect(workflow.results.summary.length).toBe('medium');

      expect(mockProvider.callModel).toHaveBeenCalledTimes(4);
    });
  });
});
