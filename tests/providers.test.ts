// This file is generated by the Architect Agent.
// Other agents must implement logic INSIDE this file only.
// Do NOT create or delete files. Respect the MIC + MIM.

import { OpenAIProvider } from '../src/core/providers/openaiProvider';
import { AnthropicProvider } from '../src/core/providers/anthropicProvider';
import { GeminiProvider } from '../src/core/providers/geminiProvider';
import { CohereProvider } from '../src/core/providers/cohereProvider';
import { ElevenLabsProvider } from '../src/core/providers/elevenLabsProvider';
import { LocalLLMProvider } from '../src/core/providers/localLLMProvider';
import { WhisperProvider } from '../src/core/providers/whisperProvider';
import { ImageModerationProvider } from '../src/core/providers/imageModerationProvider';
import { EmbeddingProvider } from '../src/core/providers/embeddingProvider';
import { ProviderRegistry } from '../src/core/providers/providerRegistry';
import { ProviderRequest, ProviderResponse } from '../src/types';

// Mock axios
const mockAxios = require('axios');
jest.mock('axios');

describe('Providers', () => {
  beforeEach(() => {
    // Reset provider registry
    (ProviderRegistry as any).providers.clear();

    // Reset axios mocks
    mockAxios.post.mockReset();
    mockAxios.get.mockReset();

    // Set up environment variables
    process.env.OPENAI_API_KEY = 'test-openai-key';
    process.env.ANTHROPIC_API_KEY = 'test-anthropic-key';
    process.env.GEMINI_API_KEY = 'test-gemini-key';
    process.env.COHERE_API_KEY = 'test-cohere-key';
    process.env.ELEVENLABS_API_KEY = 'test-elevenlabs-key';
  });

  describe('ProviderRegistry', () => {
    test('should register and retrieve providers', () => {
      const mockProvider = {
        name: 'test-provider',
        callModel: jest.fn()
      };

      ProviderRegistry.registerProvider(mockProvider);

      const retrieved = ProviderRegistry.get('test-provider');
      expect(retrieved).toBe(mockProvider);
    });

    test('should return undefined for non-existent provider', () => {
      const retrieved = ProviderRegistry.get('non-existent');
      expect(retrieved).toBeUndefined();
    });
  });

  describe('OpenAIProvider', () => {
    let provider: OpenAIProvider;

    beforeEach(() => {
      provider = new OpenAIProvider();
    });

    test('should create provider instance', () => {
      expect(provider.name).toBe('openai');
    });

    test('should call OpenAI API successfully', async () => {
      const mockResponse = {
        data: {
          choices: [{ message: { content: 'Hello from OpenAI!' } }],
          usage: { total_tokens: 150 },
          model: 'gpt-4'
        }
      };

      mockAxios.post.mockResolvedValue(mockResponse);

      const request: ProviderRequest = {
        model: 'gpt-4',
        input: 'Test message',
        options: { temperature: 0.7 }
      };

      const result = await provider.callModel(request);

      expect(result.output).toBe('Hello from OpenAI!');
      expect(result.tokens).toBe(150);
      expect(result.model).toBe('gpt-4');
      expect(result.provider).toBe('openai');

      expect(mockAxios.post).toHaveBeenCalledWith(
        'https://api.openai.com/v1/chat/completions',
        {
          model: 'gpt-4',
          messages: 'Test message',
          temperature: 0.7
        },
        expect.objectContaining({
          headers: expect.objectContaining({
            'Authorization': 'Bearer test-openai-key'
          })
        })
      );
    });

    test('should handle API errors', async () => {
      const errorResponse = {
        response: {
          data: { error: { message: 'Invalid API key' } }
        }
      };

      mockAxios.post.mockRejectedValue(errorResponse as any);

      const request: ProviderRequest = {
        model: 'gpt-4',
        input: 'Test message'
      };

      await expect(provider.callModel(request)).rejects.toThrow('OpenAI API error: Invalid API key');
    });

    test('should handle network errors', async () => {
      mockAxios.post.mockRejectedValue(new Error('Network timeout'));

      const request: ProviderRequest = {
        model: 'gpt-4',
        input: 'Test message'
      };

      await expect(provider.callModel(request)).rejects.toThrow('OpenAI provider error: Network timeout');
    });

    test('should throw error when API key is missing', async () => {
      delete process.env.OPENAI_API_KEY;

      const request: ProviderRequest = {
        model: 'gpt-4',
        input: 'Test message'
      };

      await expect(provider.callModel(request)).rejects.toThrow('OPENAI_API_KEY environment variable is required');
    });

    test('should create and register provider statically', () => {
      const createdProvider = OpenAIProvider.create();

      expect(createdProvider.name).toBe('openai');
      expect(ProviderRegistry.get('openai')).toBe(createdProvider);
    });
  });

  describe('AnthropicProvider', () => {
    let provider: AnthropicProvider;

    beforeEach(() => {
      provider = new AnthropicProvider();
    });

    test('should create provider instance', () => {
      expect(provider.name).toBe('anthropic');
    });

    test('should call Anthropic API successfully', async () => {
      const mockResponse = {
        data: {
          content: [{ text: 'Hello from Claude!' }],
          usage: { input_tokens: 10, output_tokens: 20 }
        }
      };

      mockAxios.post.mockResolvedValue(mockResponse);

      const request: ProviderRequest = {
        model: 'claude-3-sonnet-20240229',
        input: 'Test message',
        options: { max_tokens: 100 }
      };

      const result = await provider.callModel(request);

      expect(result.output).toBe('Hello from Claude!');
      expect(result.tokens).toBe(30); // input + output tokens
      expect(result.provider).toBe('anthropic');

      expect(mockAxios.post).toHaveBeenCalledWith(
        'https://api.anthropic.com/v1/messages',
        expect.objectContaining({
          model: 'claude-3-sonnet-20240229',
          messages: 'Test message',
          max_tokens: 100
        }),
        expect.objectContaining({
          headers: expect.objectContaining({
            'x-api-key': 'test-anthropic-key'
          })
        })
      );
    });

    test('should throw error when API key is missing', async () => {
      delete process.env.ANTHROPIC_API_KEY;

      const request: ProviderRequest = {
        model: 'claude-3-sonnet-20240229',
        input: 'Test message'
      };

      await expect(provider.callModel(request)).rejects.toThrow('ANTHROPIC_API_KEY environment variable is required');
    });
  });

  describe('GeminiProvider', () => {
    let provider: GeminiProvider;

    beforeEach(() => {
      provider = new GeminiProvider();
    });

    test('should create provider instance', () => {
      expect(provider.name).toBe('gemini');
    });

    test('should call Gemini API successfully', async () => {
      const mockResponse = {
        data: {
          candidates: [{
            content: { parts: [{ text: 'Hello from Gemini!' }] }
          }],
          usageMetadata: { totalTokenCount: 120 }
        }
      };

      mockAxios.post.mockResolvedValue(mockResponse);

      const request: ProviderRequest = {
        model: 'gemini-pro',
        input: 'Test message',
        options: { temperature: 0.5 }
      };

      const result = await provider.callModel(request);

      expect(result.output).toBe('Hello from Gemini!');
      expect(result.tokens).toBe(120);
      expect(result.provider).toBe('gemini');
    });

    test('should throw error when API key is missing', async () => {
      delete process.env.GEMINI_API_KEY;

      const request: ProviderRequest = {
        model: 'gemini-pro',
        input: 'Test message'
      };

      await expect(provider.callModel(request)).rejects.toThrow('GEMINI_API_KEY environment variable is required');
    });
  });

  describe('CohereProvider', () => {
    let provider: CohereProvider;

    beforeEach(() => {
      provider = new CohereProvider();
    });

    test('should create provider instance', () => {
      expect(provider.name).toBe('cohere');
    });

    test('should call Cohere API successfully', async () => {
      const mockResponse = {
        data: {
          text: 'Hello from Cohere!',
          meta: {
            tokens: {
              input_tokens: 10,
              output_tokens: 15
            }
          }
        }
      };

      mockAxios.post.mockResolvedValue(mockResponse);

      const request: ProviderRequest = {
        model: 'command',
        input: 'Test message',
        options: { temperature: 0.7 }
      };

      const result = await provider.callModel(request);

      expect(result.output).toBe('Hello from Cohere!');
      expect(result.tokens).toBe(25); // input + output tokens
      expect(result.provider).toBe('cohere');
    });
  });

  describe('ElevenLabsProvider', () => {
    let provider: ElevenLabsProvider;

    beforeEach(() => {
      provider = new ElevenLabsProvider();
    });

    test('should create provider instance', () => {
      expect(provider.name).toBe('elevenlabs');
    });

    test('should call ElevenLabs API for TTS', async () => {
      const mockAudioBuffer = new ArrayBuffer(4096);
      mockAxios.post.mockResolvedValue({ data: mockAudioBuffer });

      const request: ProviderRequest = {
        model: 'eleven_monolingual_v1',
        input: 'Hello world',
        options: { voice: 'test-voice' }
      };

      const result = await provider.callModel(request);

      expect(result.output).toBe(mockAudioBuffer);
      expect(result.provider).toBe('elevenlabs');
    });
  });

  describe('WhisperProvider', () => {
    let provider: WhisperProvider;

    beforeEach(() => {
      provider = new WhisperProvider();
    });

    test('should create provider instance', () => {
      expect(provider.name).toBe('whisper');
    });

    test('should call Whisper API for STT', async () => {
      const mockResponse = {
        data: {
          text: 'Transcribed text from audio',
          language: 'en'
        }
      };

      mockAxios.post.mockResolvedValue(mockResponse);

      const audioBuffer = new ArrayBuffer(1024);
      const request: ProviderRequest = {
        model: 'whisper-1',
        input: audioBuffer,
        options: { language: 'en' }
      };

      const result = await provider.callModel(request);

      expect(result.output).toBe('Transcribed text from audio');
      expect(result.provider).toBe('whisper');
    });
  });

  describe('LocalLLMProvider', () => {
    let provider: LocalLLMProvider;

    beforeEach(() => {
      provider = new LocalLLMProvider();
      process.env.LOCAL_MODEL_PATH = '/path/to/model';
    });

    test('should create provider instance', () => {
      expect(provider.name).toBe('local');
    });

    test('should throw error when model path is missing', async () => {
      delete process.env.LOCAL_MODEL_PATH;

      const request: ProviderRequest = {
        model: 'local-model',
        input: 'Test message'
      };

      await expect(provider.callModel(request)).rejects.toThrow('LOCAL_MODEL_PATH environment variable is required');
    });

    test('should simulate local model call', async () => {
      const request: ProviderRequest = {
        model: 'local-model',
        input: 'Test message'
      };

      const result = await provider.callModel(request);

      expect(typeof result.output).toBe('string');
      expect(result.provider).toBe('local');
    });
  });

  describe('ImageModerationProvider', () => {
    let provider: ImageModerationProvider;

    beforeEach(() => {
      provider = new ImageModerationProvider();
    });

    test('should create provider instance', () => {
      expect(provider.name).toBe('image_moderation');
    });

    test('should moderate images', async () => {
      const mockResponse = {
        data: {
          results: [{ label: 'safe', confidence: 0.95 }]
        }
      };

      mockAxios.post.mockResolvedValue(mockResponse);

      const imageBuffer = new ArrayBuffer(2048);
      const request: ProviderRequest = {
        model: 'moderation-model',
        input: imageBuffer
      };

      const result = await provider.callModel(request);

      expect(result.output).toEqual(mockResponse.data);
      expect(result.provider).toBe('image_moderation');
    });
  });

  describe('EmbeddingProvider', () => {
    let provider: EmbeddingProvider;

    beforeEach(() => {
      provider = new EmbeddingProvider();
    });

    test('should create provider instance', () => {
      expect(provider.name).toBe('embedding');
    });

    test('should generate embeddings', async () => {
      const mockEmbeddings = [0.1, 0.2, 0.3, 0.4, 0.5];
      const mockResponse = {
        data: {
          data: [{ embedding: mockEmbeddings }]
        }
      };

      mockAxios.post.mockResolvedValue(mockResponse);

      const request: ProviderRequest = {
        model: 'text-embedding-ada-002',
        input: 'Test text for embedding'
      };

      const result = await provider.callModel(request);

      expect(result.output).toEqual({
        embedding: mockEmbeddings,
        dimensions: 5
      });
      expect(result.provider).toBe('embedding');
    });
  });
});
