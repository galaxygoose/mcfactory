// This file is generated by the Architect Agent.
// Other agents must implement logic INSIDE this file only.
// Do NOT create or delete files. Respect the MIC + MIM.

import { TrainingFactory } from '../src/core/factories/TrainingFactory';
import { TrainingExample, DatasetBundle, TrainingExportConfig } from '../src/types';

describe('Training', () => {
  let factory: TrainingFactory;

  beforeEach(() => {
    factory = new TrainingFactory();
  });

  describe('TrainingFactory', () => {
    test('should export training data in JSONL format', async () => {
      const examples: TrainingExample[] = [
        {
          input: 'Translate hello to Spanish',
          output: 'Hola',
          task: 'translation',
          metadata: { difficulty: 'easy' }
        },
        {
          input: 'What is the capital of France?',
          output: 'Paris',
          task: 'qa',
          metadata: { subject: 'geography' }
        }
      ];

      const result = await factory.run(examples, {
        metadata: { format: 'jsonl', shardSize: 1000 }
      });

      expect(result).toHaveProperty('manifest');
      expect(result).toHaveProperty('files');
      expect(result.manifest.format).toBe('jsonl');
      expect(result.manifest.statistics.totalExamples).toBe(2);
      expect(result.manifest.statistics.tasks).toEqual(['translation', 'qa']);
      expect(result.files.length).toBeGreaterThan(0);
      expect(result.files[0]).toContain('jsonl');
    });

    test('should export training data in CSV format', async () => {
      const examples: TrainingExample[] = [
        {
          input: 'Hello world',
          output: 'Hola mundo',
          task: 'translation'
        }
      ];

      const result = await factory.run(examples, {
        metadata: { format: 'csv' }
      });

      expect(result.manifest.format).toBe('csv');
      expect(result.files.some(file => file.endsWith('.csv'))).toBe(true);
    });

    test('should export training data in Parquet format', async () => {
      const examples: TrainingExample[] = [
        {
          input: 'Test input',
          output: 'Test output',
          task: 'test'
        }
      ];

      const result = await factory.run(examples, {
        metadata: { format: 'parquet' }
      });

      expect(result.manifest.format).toBe('parquet');
      expect(result.files.some(file => file.endsWith('.parquet'))).toBe(true);
    });

    test('should export training data in Hugging Face format', async () => {
      const examples: TrainingExample[] = [
        {
          input: 'Translate this',
          output: 'Traduce esto',
          task: 'translation'
        }
      ];

      const result = await factory.run(examples, {
        metadata: { format: 'hf' }
      });

      expect(result.manifest.format).toBe('hf');
    });

    test('should validate training examples', async () => {
      const invalidExamples = [
        { input: '', task: 'invalid' } // Empty input
      ];

      await expect(factory.run(invalidExamples as TrainingExample[]))
        .rejects.toThrow('Each training example must have a valid input string');
    });

    test('should handle empty examples array', async () => {
      await expect(factory.run([]))
        .rejects.toThrow('Training examples must be a non-empty array');
    });

    test('should create proper manifest with statistics', async () => {
      const examples: TrainingExample[] = [
        {
          input: 'Short input',
          output: 'Short output',
          task: 'test'
        },
        {
          input: 'This is a much longer input that should affect the average length calculation',
          output: 'Longer output response',
          task: 'test'
        }
      ];

      const result = await factory.run(examples);

      expect(result.manifest).toHaveProperty('version');
      expect(result.manifest).toHaveProperty('created');
      expect(result.manifest.statistics.totalExamples).toBe(2);
      expect(result.manifest.statistics.tasks).toEqual(['test']);
      expect(result.manifest.statistics.avgInputLength).toBeGreaterThan(0);
      expect(result.manifest.statistics.hasOutputs).toBe(true);
    });

    test('should handle examples without outputs', async () => {
      const examples: TrainingExample[] = [
        {
          input: 'Input without output',
          task: 'classification'
        }
      ];

      const result = await factory.run(examples);

      expect(result.manifest.statistics.hasOutputs).toBe(false);
    });

    test('should use default configuration when no options provided', async () => {
      const examples: TrainingExample[] = [
        {
          input: 'Test input',
          output: 'Test output',
          task: 'test'
        }
      ];

      const result = await factory.run(examples);

      expect(result.manifest.format).toBe('jsonl');
      expect(result.manifest.config.shardSize).toBe(1000);
      expect(result.manifest.config.schedule).toBe('manual');
    });

    test('should handle custom configuration options', async () => {
      const examples: TrainingExample[] = [
        {
          input: 'Test input',
          task: 'test'
        }
      ];

      const customConfig: TrainingExportConfig = {
        format: 'csv',
        shardSize: 500,
        schedule: 'daily',
        outputDir: '/custom/path'
      };

      const result = await factory.run(examples, {
        metadata: customConfig
      });

      expect(result.manifest.format).toBe('csv');
      expect(result.manifest.config.shardSize).toBe(500);
      expect(result.manifest.config.schedule).toBe('daily');
      expect(result.manifest.config.outputDir).toBe('/custom/path');
    });

    test('should shard large datasets', async () => {
      const examples: TrainingExample[] = Array.from({ length: 2500 }, (_, i) => ({
        input: `Input ${i}`,
        output: `Output ${i}`,
        task: 'test'
      }));

      const result = await factory.run(examples, {
        metadata: { format: 'jsonl', shardSize: 1000 }
      });

      // Should create 3 shards (1000, 1000, 500) plus manifest
      expect(result.files.length).toBeGreaterThan(3);
      expect(result.files.filter(f => f.includes('shard')).length).toBe(3);
      expect(result.files.some(f => f.includes('manifest'))).toBe(true);
    });

    test('should handle metadata in examples', async () => {
      const examples: TrainingExample[] = [
        {
          input: 'Test input',
          output: 'Test output',
          task: 'test',
          metadata: {
            difficulty: 'hard',
            category: 'math',
            score: 0.95
          }
        }
      ];

      const result = await factory.run(examples, {
        metadata: { format: 'csv' }
      });

      expect(result.manifest.statistics.totalExamples).toBe(1);
      // CSV format should handle metadata columns
      expect(result.files.some(f => f.endsWith('.csv'))).toBe(true);
    });

    test('should reject unsupported formats', async () => {
      const examples: TrainingExample[] = [
        {
          input: 'Test input',
          task: 'test'
        }
      ];

      await expect(factory.run(examples, {
        metadata: { format: 'unsupported' as any }
      })).rejects.toThrow('Unsupported format: unsupported');
    });

    test('should handle debug mode', async () => {
      const examples: TrainingExample[] = [
        {
          input: 'Test input',
          task: 'test'
        }
      ];

      const consoleSpy = jest.spyOn(console, 'log').mockImplementation();

      await factory.run(examples, { debug: true });

      expect(consoleSpy).toHaveBeenCalledWith('Training dataset export:', expect.any(Object));

      consoleSpy.mockRestore();
    });

    test('should generate unique filenames with timestamps', async () => {
      const examples: TrainingExample[] = [
        {
          input: 'Test input',
          task: 'test'
        }
      ];

      // Mock Date.now to return different values
      const originalDateNow = Date.now;
      Date.now = jest.fn()
        .mockReturnValueOnce(1000000000000)
        .mockReturnValueOnce(2000000000000);

      const result1 = await factory.run(examples);
      const result2 = await factory.run(examples);

      // Restore Date.now
      Date.now = originalDateNow;

      // Filenames should be different due to timestamps
      const filename1 = result1.files[0];
      const filename2 = result2.files[0];

      expect(filename1).not.toBe(filename2);
      expect(filename1).toContain('1000000000000');
      expect(filename2).toContain('2000000000000');
    });
  });

  describe('Training Data Processing', () => {
    test('should convert examples to JSONL format', async () => {
      const examples: TrainingExample[] = [
        {
          input: 'Hello',
          output: 'Hi there',
          task: 'greeting'
        }
      ];

      const result = await factory.run(examples, {
        metadata: { format: 'jsonl' }
      });

      expect(result.manifest.format).toBe('jsonl');
      expect(result.files.some(f => f.includes('jsonl'))).toBe(true);
    });

    test('should handle complex CSV conversion with nested metadata', async () => {
      const examples: TrainingExample[] = [
        {
          input: 'Complex input',
          output: 'Complex output',
          task: 'complex',
          metadata: {
            nested: { value: 42 },
            array: [1, 2, 3],
            string: 'test'
          }
        }
      ];

      const result = await factory.run(examples, {
        metadata: { format: 'csv' }
      });

      expect(result.manifest.format).toBe('csv');
      // Should handle JSON serialization of complex objects
    });

    test('should create proper schema for Parquet format', async () => {
      const examples: TrainingExample[] = [
        {
          input: 'Schema test',
          output: 'Schema output',
          task: 'schema',
          metadata: { number: 123, boolean: true }
        }
      ];

      const result = await factory.run(examples, {
        metadata: { format: 'parquet' }
      });

      expect(result.manifest.format).toBe('parquet');
      // In a real implementation, this would validate the schema
    });
  });

  describe('Training Configuration', () => {
    test('should extract configuration from factory options', async () => {
      const examples: TrainingExample[] = [
        { input: 'Test', task: 'test' }
      ];

      const customOptions = {
        format: 'csv' as const,
        shardSize: 500,
        schedule: 'weekly' as const,
        outputDir: '/custom/output'
      };

      const result = await factory.run(examples, {
        metadata: customOptions
      });

      expect(result.manifest.config).toEqual(customOptions);
    });

    test('should use default values for missing configuration', async () => {
      const examples: TrainingExample[] = [
        { input: 'Test', task: 'test' }
      ];

      const result = await factory.run(examples, {
        metadata: { format: 'jsonl' }
      });

      expect(result.manifest.config.shardSize).toBe(1000);
      expect(result.manifest.config.schedule).toBe('manual');
      expect(result.manifest.config.outputDir).toBe('./datasets');
    });
  });
});
